<?xml version="1.0" encoding="UTF-8"?>
<!--
  Story Context: 5-5-apply-color-schemes-to-grayscale-intensity-buffers
  Epic: 5 - Color Scheme System
  Generated: 2025-11-24

  Purpose: Provide comprehensive context for implementing color scheme
  application to grayscale intensity buffers, enabling beautiful colored
  terminal visualizations from grayscale image data.
-->
<story-context story-id="5-5" epic-id="5">
  <story-summary>
    <title>Apply Color Schemes to Grayscale Intensity Buffers</title>
    <goal>Implement intensity-to-color mapping that applies ColorScheme to intensity buffers, producing RGB colors for terminal rendering</goal>
    <acceptance-criteria>
      <criterion id="AC1">apply_scheme() maps intensity buffer → Color buffer</criterion>
      <criterion id="AC2">Linear interpolation between color stops for smooth gradients</criterion>
      <criterion id="AC3">Intensity bounds checking (clamp 0.0-1.0 with warning logs)</criterion>
      <criterion id="AC4">Integration with BrailleGrid.apply_intensity_colors()</criterion>
      <criterion id="AC5">All 6 built-in schemes produce correct colors</criterion>
      <criterion id="AC6">Custom schemes work identically to built-in</criterion>
      <criterion id="AC7">Performance: &lt;1ms for 80×24 grid (1,920 cells)</criterion>
    </acceptance-criteria>
  </story-summary>

  <technical-context>
    <architecture-decisions>
      <!-- From architecture.md -->
      <decision id="ADR-COLOR">
        Color processing follows the pipeline: Image → Grayscale → Intensity Buffer → Color Scheme → RGB
        The ColorScheme system maps f32 intensity values (0.0-1.0) to RGB colors using linear interpolation.
      </decision>
      <decision id="ADR-PERFORMANCE">
        All hot-path operations target sub-millisecond performance for interactive rendering.
        Color mapping should use SIMD-friendly patterns where possible.
      </decision>
    </architecture-decisions>

    <related-stories>
      <story id="5-3" status="done">Extract and Integrate 6 Color Schemes from crabmusic - Provides built-in schemes</story>
      <story id="5-4" status="done">Implement Custom Color Scheme Creation and Intensity Mapping - Provides ColorScheme API and color stops</story>
      <story id="2-6" status="done">Color rendering infrastructure in BrailleGrid</story>
    </related-stories>
  </technical-context>

  <existing-code>
    <!-- ColorScheme from Story 5-4 (src/color/schemes.rs) -->
    <module name="src/color/schemes.rs" purpose="Color scheme definitions and intensity mapping">
      <key-types>
        <type name="ColorScheme" description="Represents a gradient of colors for intensity mapping">
          <field>stops: Vec&lt;ColorStop&gt;</field>
          <field>name: &amp;'static str</field>
          <method>map_intensity(intensity: f32) -> (u8, u8, u8)</method>
          <method>builder() -> ColorSchemeBuilder</method>
        </type>
        <type name="ColorStop" description="A color at a specific intensity position">
          <field>intensity: f32 (0.0-1.0)</field>
          <field>r: u8, g: u8, b: u8</field>
        </type>
        <type name="ColorSchemeBuilder" description="Builder pattern for custom schemes">
          <method>with_name(name: &amp;'static str) -> Self</method>
          <method>add_stop(intensity: f32, r: u8, g: u8, b: u8) -> Result&lt;Self, DotmaxError&gt;</method>
          <method>build() -> Result&lt;ColorScheme, DotmaxError&gt;</method>
        </type>
      </key-types>
      <built-in-schemes>
        <scheme name="FIRE" colors="Black → Red → Orange → Yellow → White" purpose="Heat map visualization"/>
        <scheme name="ICE" colors="White → Light Blue → Blue → Dark Blue → Black" purpose="Cold/inverse visualization"/>
        <scheme name="OCEAN" colors="Dark Blue → Blue → Cyan → Light Cyan → White" purpose="Ocean depth visualization"/>
        <scheme name="FOREST" colors="Black → Dark Green → Green → Light Green → White" purpose="Nature/vegetation"/>
        <scheme name="PLASMA" colors="Black → Purple → Magenta → Pink → White" purpose="Plasma/energy visualization"/>
        <scheme name="GRAYSCALE" colors="Black → Gray → White" purpose="Monochrome output"/>
      </built-in-schemes>
    </module>

    <!-- BrailleGrid Color Support from Story 2-6 (src/grid.rs) -->
    <module name="src/grid.rs" purpose="Braille grid with per-cell color support">
      <key-types>
        <type name="BrailleGrid">
          <field>colors: Vec&lt;Option&lt;Color&gt;&gt; - Per-cell color buffer</field>
          <method>set_cell_color(x: usize, y: usize, color: Color) -> Result&lt;(), DotmaxError&gt;</method>
          <method>get_color(x: usize, y: usize) -> Option&lt;Color&gt;</method>
          <method>clear_colors()</method>
          <method>enable_color_support()</method>
          <method>dimensions() -> (usize, usize)</method>
        </type>
        <type name="Color">
          <field>r: u8, g: u8, b: u8</field>
          <method>rgb(r: u8, g: u8, b: u8) -> Self</method>
          <method>black() -> Self</method>
          <method>white() -> Self</method>
        </type>
      </key-types>
      <note>Grid already has colors buffer and set_cell_color() - Story 5-5 adds bulk intensity application</note>
    </module>

    <!-- Color Conversion from Story 5-2 (src/color/convert.rs) -->
    <module name="src/color/convert.rs" purpose="RGB to terminal color conversion">
      <functions>
        <function name="rgb_to_terminal_color(r, g, b, capability) -> String">
          Converts RGB to appropriate escape code based on terminal capability
        </function>
        <function name="rgb_to_ansi256(r, g, b) -> u8">
          Converts RGB to nearest ANSI 256 palette index
        </function>
        <function name="rgb_to_ansi16(r, g, b) -> u8">
          Converts RGB to nearest ANSI 16 palette index
        </function>
      </functions>
    </module>

    <!-- Terminal Capabilities from Story 5-1 (src/utils/terminal_caps.rs) -->
    <module name="src/utils/terminal_caps.rs" purpose="Terminal color capability detection">
      <types>
        <type name="ColorCapability" variants="Monochrome|Ansi16|Ansi256|TrueColor">
          <method>detect() -> Self</method>
          <method>supports_color() -> bool</method>
          <method>supports_truecolor() -> bool</method>
        </type>
      </types>
    </module>

    <!-- Error Types (src/error.rs) -->
    <module name="src/error.rs" purpose="Error handling">
      <relevant-variants>
        <variant name="BufferSizeMismatch">expected: usize, actual: usize - For intensity buffer validation</variant>
        <variant name="InvalidIntensity(f32)">For intensity values outside 0.0-1.0</variant>
        <variant name="EmptyColorScheme">When color scheme has no colors</variant>
        <variant name="OutOfBounds">For grid coordinate errors</variant>
      </relevant-variants>
    </module>
  </existing-code>

  <implementation-guidance>
    <task id="1" title="Implement apply_scheme() function">
      <description>
        Create a function that maps an intensity buffer to RGB colors using a ColorScheme.
        This is the core intensity-to-color mapping function.
      </description>
      <location>src/color/schemes.rs or src/color/mod.rs</location>
      <signature>
        pub fn apply_scheme(
            intensities: &amp;[f32],
            scheme: &amp;ColorScheme,
        ) -> Vec&lt;(u8, u8, u8)&gt;
      </signature>
      <algorithm>
        1. Validate intensity buffer is not empty
        2. For each intensity value:
           a. Clamp to 0.0-1.0 range (log warning if out of bounds)
           b. Call scheme.map_intensity(intensity) to get RGB
           c. Collect into result vector
        3. Return Vec of RGB tuples
      </algorithm>
      <considerations>
        - Pre-allocate result vector with correct capacity for performance
        - Use iterators for functional style matching existing code
        - Log warnings for out-of-bounds intensities using tracing
      </considerations>
    </task>

    <task id="2" title="Implement BrailleGrid.apply_intensity_colors()">
      <description>
        Add a method to BrailleGrid that applies a color scheme to an intensity buffer,
        setting colors for each cell based on intensity values.
      </description>
      <location>src/grid.rs</location>
      <signature>
        pub fn apply_intensity_colors(
            &amp;mut self,
            intensities: &amp;[f32],
            scheme: &amp;ColorScheme,
        ) -> Result&lt;(), DotmaxError&gt;
      </signature>
      <algorithm>
        1. Validate buffer size matches grid (width * height)
        2. Enable color support on grid if not already enabled
        3. Call apply_scheme() to get color buffer
        4. For each (index, rgb) in color buffer:
           a. Calculate (x, y) from index
           b. Call set_cell_color(x, y, Color::rgb(r, g, b))
        5. Return Ok(())
      </algorithm>
      <error-handling>
        - Return BufferSizeMismatch if intensities.len() != width * height
        - Propagate any errors from set_cell_color (should not occur if bounds correct)
      </error-handling>
    </task>

    <task id="3" title="Linear interpolation in map_intensity()">
      <description>
        Verify or enhance ColorScheme.map_intensity() to perform smooth linear
        interpolation between adjacent color stops.
      </description>
      <algorithm>
        Given intensity i and stops [s1, s2, ...]:
        1. Find the two stops bracketing intensity i
        2. Calculate t = (i - s1.intensity) / (s2.intensity - s1.intensity)
        3. Interpolate each channel: r = s1.r + t * (s2.r - s1.r)
        4. Return interpolated (r, g, b)
      </algorithm>
      <edge-cases>
        - intensity == 0.0: Return first stop color
        - intensity == 1.0: Return last stop color
        - intensity exactly on a stop: Return that stop's color
        - Single-stop scheme: Always return that color
      </edge-cases>
    </task>

    <task id="4" title="Intensity bounds checking with warnings">
      <description>
        Add bounds checking that clamps intensities to 0.0-1.0 and logs warnings
        for out-of-bounds values.
      </description>
      <implementation>
        Use tracing::warn! for out-of-bounds values:
        - "Intensity {value} clamped to 0.0 (was below minimum)"
        - "Intensity {value} clamped to 1.0 (was above maximum)"
      </implementation>
      <note>Only log warnings, don't fail - graceful degradation is preferred</note>
    </task>

    <task id="5" title="Unit tests for all built-in schemes">
      <description>
        Write comprehensive tests verifying each built-in scheme produces correct
        colors at key intensity points.
      </description>
      <test-cases>
        - FIRE at 0.0 → Black (0, 0, 0)
        - FIRE at 1.0 → White (255, 255, 255)
        - FIRE at 0.5 → Orange-ish (verify interpolation)
        - ICE at 0.0 → White
        - ICE at 1.0 → Black (inverted)
        - GRAYSCALE at 0.5 → Mid-gray (128, 128, 128)
        - All schemes: smooth gradients between stops
      </test-cases>
    </task>

    <task id="6" title="Performance benchmarks">
      <description>
        Add benchmarks to verify &lt;1ms performance for 80×24 grid.
      </description>
      <location>benches/color_schemes.rs</location>
      <benchmark>
        - Create 1,920 element intensity buffer (80×24)
        - Time apply_scheme() call
        - Assert &lt;1ms (1,000,000 ns)
      </benchmark>
    </task>
  </implementation-guidance>

  <testing-requirements>
    <test-coverage>
      <area name="apply_scheme() function">
        - Empty buffer handling
        - Single-element buffer
        - Standard 80×24 buffer
        - All built-in schemes produce valid RGB
        - Custom scheme produces expected colors
      </area>
      <area name="BrailleGrid.apply_intensity_colors()">
        - Buffer size validation (mismatch returns error)
        - Correct buffer size succeeds
        - All cells receive colors
        - Colors match expected scheme output
      </area>
      <area name="Linear interpolation">
        - Exact intensity matches stop → returns that stop color
        - Midpoint between stops → returns average
        - Edge intensities (0.0, 1.0) → return first/last stop
      </area>
      <area name="Bounds checking">
        - Negative intensity → clamped to 0.0, warning logged
        - Intensity > 1.0 → clamped to 1.0, warning logged
        - NaN handling (if applicable)
      </area>
    </test-coverage>
    <existing-test-patterns>
      <!-- Follow patterns from src/color/convert.rs tests -->
      <pattern>Use assert_eq! for exact color matching</pattern>
      <pattern>Test all variants of enums (each scheme)</pattern>
      <pattern>Test error conditions with assert!(matches!(...))</pattern>
    </existing-test-patterns>
  </testing-requirements>

  <dependencies>
    <crate name="tracing" version="0.1" use="Structured logging for warnings"/>
    <internal-module name="src/color/schemes.rs">ColorScheme, ColorStop, built-in schemes</internal-module>
    <internal-module name="src/grid.rs">BrailleGrid, Color</internal-module>
    <internal-module name="src/error.rs">DotmaxError variants</internal-module>
  </dependencies>

  <code-style>
    <conventions>
      <convention>Use #[inline] for small hot-path functions</convention>
      <convention>Add #[must_use] to all pure functions returning values</convention>
      <convention>Use Result&lt;T, DotmaxError&gt; for fallible operations</convention>
      <convention>Comprehensive doc comments with examples on all public APIs</convention>
      <convention>Use tracing macros (debug!, warn!, info!) not println!</convention>
    </conventions>
    <formatting>
      <rule>cargo fmt before commit</rule>
      <rule>cargo clippy --all-features with deny all, warn pedantic/nursery</rule>
    </formatting>
  </code-style>

  <definition-of-done>
    <item>All acceptance criteria met and tested</item>
    <item>apply_scheme() function implemented and tested</item>
    <item>BrailleGrid.apply_intensity_colors() implemented and tested</item>
    <item>Linear interpolation verified for smooth gradients</item>
    <item>All 6 built-in schemes tested</item>
    <item>Custom schemes work identically</item>
    <item>Performance benchmark confirms &lt;1ms for 80×24</item>
    <item>cargo test passes</item>
    <item>cargo clippy --all-features passes</item>
    <item>cargo fmt --check passes</item>
  </definition-of-done>
</story-context>
