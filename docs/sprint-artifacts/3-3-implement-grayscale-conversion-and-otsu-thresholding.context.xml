<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3</storyId>
    <title>Implement Grayscale Conversion and Otsu Thresholding</title>
    <status>drafted</status>
    <generatedAt>2025-11-19</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/3-3-implement-grayscale-conversion-and-otsu-thresholding.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer converting images to binary braille patterns</asA>
    <iWant>intelligent grayscale conversion with optimal thresholding</iWant>
    <soThat>braille output has clear contrast and detail</soThat>
    <tasks>
- Task 1: Create module structure and data types (8 subtasks)
  - Create src/image/convert.rs and src/image/threshold.rs files
  - Add module exports to src/image/mod.rs
  - Define BinaryImage struct with width, height, pixels fields
  - Add module-level rustdoc documentation
  - Import necessary types from image crate (DynamicImage, GrayImage, Luma)

- Task 2: Implement grayscale conversion (8 subtasks)
  - Implement to_grayscale(image: &DynamicImage) -> GrayImage signature
  - Use image::DynamicImage::to_luma8() for standard luminance conversion
  - Verify luminance formula: Y = 0.299*R + 0.587*G + 0.114*B
  - Handle already-grayscale images (DynamicImage::ImageLuma8 variant)
  - Add tracing logs for conversion operations
  - Add rustdoc with examples showing RGB → grayscale conversion
  - Unit test: verify color image converts to grayscale correctly
  - Unit test: verify grayscale image passes through unchanged

- Task 3: Implement Otsu threshold calculation (8 subtasks)
  - Implement otsu_threshold(gray: &GrayImage) -> u8 signature
  - Check if imageproc::threshold::otsu_level() exists, use if available
  - If not available, implement Otsu's method from scratch (histogram, variance calculation)
  - Handle edge cases (all-black, all-white, uniform images)
  - Ensure calculation completes in <5ms per tech spec budget
  - Add tracing logs for threshold calculation
  - Add rustdoc explaining Otsu's method and when to use it
  - Add reference to Otsu paper in documentation

- Task 4: Implement binary conversion with threshold (10 subtasks)
  - Implement apply_threshold(gray: &GrayImage, threshold: u8) -> BinaryImage
  - Create BinaryImage with same dimensions as input
  - Iterate pixels: if pixel >= threshold → true (black), else false (white)
  - Store boolean values in Vec<bool> pixels field
  - Implement auto_threshold(image: &DynamicImage) -> BinaryImage pipeline
  - Pipeline: call to_grayscale() → otsu_threshold() → apply_threshold()
  - Add tracing logs for threshold application
  - Add rustdoc with examples for both functions
  - Unit test: verify threshold application (simple test pattern)
  - Unit test: verify auto_threshold pipeline works end-to-end

- Task 5: Implement brightness adjustment (10 subtasks)
  - Implement adjust_brightness(gray: &GrayImage, factor: f32) -> Result<GrayImage, DotmaxError>
  - Validate factor range: 0.0 to 2.0 (return InvalidParameter if outside)
  - Apply brightness formula: new_pixel = (old_pixel * factor).clamp(0.0, 255.0)
  - Create new GrayImage with adjusted pixels
  - Add tracing logs for brightness adjustment
  - Add rustdoc explaining brightness adjustment (multiplicative scaling)
  - Unit test: brightness factor 0.5 darkens image
  - Unit test: brightness factor 1.5 brightens image
  - Unit test: brightness factor 1.0 is no-op
  - Unit test: invalid factors return error

- Task 6: Implement contrast adjustment (10 subtasks)
  - Implement adjust_contrast(gray: &GrayImage, factor: f32) -> Result<GrayImage, DotmaxError>
  - Validate factor range: 0.0 to 2.0 (return InvalidParameter if outside)
  - Apply contrast formula: new_pixel = ((old - 128) * factor + 128).clamp(0, 255)
  - Pivot around middle gray (128) to preserve overall brightness
  - Create new GrayImage with adjusted pixels
  - Add tracing logs for contrast adjustment
  - Add rustdoc explaining contrast adjustment formula
  - Unit test: contrast factor 0.5 reduces contrast
  - Unit test: contrast factor 1.5 increases contrast
  - Unit test: contrast factor 1.0 is no-op

- Task 7: Implement gamma correction (10 subtasks)
  - Implement adjust_gamma(gray: &GrayImage, gamma: f32) -> Result<GrayImage, DotmaxError>
  - Validate gamma range: 0.1 to 3.0 (return InvalidParameter if outside)
  - Apply gamma formula: new_pixel = 255.0 * ((old / 255.0).powf(gamma))
  - Clamp result to 0-255 and convert to u8
  - Create new GrayImage with gamma-corrected pixels
  - Add tracing logs for gamma correction
  - Add rustdoc explaining gamma correction (gamma < 1 brightens, > 1 darkens)
  - Unit test: gamma 0.5 brightens image
  - Unit test: gamma 2.0 darkens image
  - Unit test: gamma 1.0 is no-op

- Task 8: Add error handling for invalid parameters (8 subtasks)
  - Add InvalidParameter variant to DotmaxError enum in src/error.rs
  - Error message format: "Invalid {parameter_name}: {value} (valid range: {min}-{max})"
  - Validate brightness factor in adjust_brightness() (0.0-2.0)
  - Validate contrast factor in adjust_contrast() (0.0-2.0)
  - Validate gamma value in adjust_gamma() (0.1-3.0)
  - Handle empty images gracefully (0 width or height)
  - Add unit tests for all error paths
  - Verify zero panics guarantee (grep for .unwrap() / .expect())

- Task 9: Write unit tests for Otsu algorithm (8 subtasks)
  - Create test image: all black pixels → Otsu should return 0 or low value
  - Create test image: all white pixels → Otsu should return 255 or high value
  - Create test image: uniform gray (128) → Otsu should return ~128
  - Create test image: bimodal distribution (half black, half white) → Otsu ~127
  - Test known image with documented Otsu threshold value
  - Test edge case: 1×1 image
  - Test edge case: very large image (1000×1000) completes in <5ms
  - Verify threshold always in range 0-255

- Task 10: Write unit tests for grayscale conversion (8 subtasks)
  - Create RGB test image with known pixel values
  - Verify luminance formula: Y = 0.299*R + 0.587*G + 0.114*B
  - Test pure red (255, 0, 0) → gray ~76 (0.299 * 255)
  - Test pure green (0, 255, 0) → gray ~150 (0.587 * 255)
  - Test pure blue (0, 0, 255) → gray ~29 (0.114 * 255)
  - Test white (255, 255, 255) → gray 255
  - Test black (0, 0, 0) → gray 0
  - Test already-grayscale image passes through correctly

- Task 11: Write integration tests (7 subtasks)
  - Integration test: load PNG (Story 3.1) → resize (Story 3.2) → grayscale → verify
  - Integration test: load color image → auto_threshold → verify BinaryImage
  - Integration test: adjust brightness → threshold → compare results
  - Integration test: adjust contrast → threshold → compare results
  - Integration test: adjust gamma → threshold → compare results
  - Integration test: chain adjustments (brightness + contrast + gamma) → threshold
  - Error handling integration test: invalid parameters return errors (not panics)

- Task 12: Add performance benchmarks (9 subtasks)
  - Benchmark grayscale conversion for 160×96 image (80×24 terminal)
  - Benchmark Otsu threshold calculation for 160×96 image
  - Benchmark apply_threshold for 160×96 image
  - Benchmark auto_threshold full pipeline
  - Benchmark brightness adjustment
  - Benchmark contrast adjustment
  - Benchmark gamma correction
  - Verify grayscale <2ms, Otsu <5ms, total <10ms targets met
  - Add benchmarks to benches/image_conversion.rs or create new file

- Task 13: Documentation and examples (9 subtasks)
  - Add module-level rustdoc to convert.rs explaining grayscale conversion
  - Add module-level rustdoc to threshold.rs explaining Otsu method
  - Add function-level rustdoc with examples for all public functions
  - Document Otsu's method with reference to original paper (Nobuyuki Otsu, 1979)
  - Document brightness/contrast/gamma formulas with visual explanations
  - Create examples/threshold_demo.rs showing grayscale → threshold
  - Example shows auto_threshold and manual threshold comparison
  - Example demonstrates brightness/contrast/gamma adjustments
  - Test example compiles: cargo run --example threshold_demo --features image

- Task 14: Export public API (5 subtasks)
  - Export BinaryImage from src/image/mod.rs
  - Export grayscale conversion functions from convert module
  - Export threshold functions from threshold module
  - Verify all public types/functions behind #[cfg(feature = "image")]
  - Update module documentation in src/image/mod.rs with new capabilities

- Task 15: Validation and cleanup (7 subtasks)
  - Run cargo test --features image - all tests pass
  - Run cargo clippy --features image -- -D warnings - zero warnings
  - Run cargo fmt - code formatted
  - Verify zero panics guarantee (no .unwrap() / .expect() in production code)
  - Run benchmarks, verify performance targets met (<2ms grayscale, <5ms Otsu)
  - Visual check: example program shows thresholded images
  - Integration check: pipeline works (load → resize → grayscale → threshold)
    </tasks>
  </story>

  <acceptanceCriteria>
AC1: Grayscale Conversion Functionality
- to_grayscale() function converts DynamicImage to GrayImage
- Works with color images (RGB/RGBA) using luminance formula
- Works with already-grayscale images (pass-through or ensure consistency)
- Uses standard luminance conversion: Y = 0.299*R + 0.587*G + 0.114*B
- Returns 8-bit grayscale (GrayImage from image crate)

AC2: Otsu Threshold Calculation
- otsu_threshold() function calculates optimal threshold automatically
- Returns threshold value 0-255 (u8)
- Implements Otsu's method (maximizes between-class variance)
- Handles edge cases (all-black, all-white, uniform images)
- Calculation completes in <5ms per tech spec budget

AC3: Binary Image Conversion
- BinaryImage struct defined with width, height, pixels: Vec<bool>
- apply_threshold() function converts grayscale to binary using threshold
- Pixels above threshold → true (black), below threshold → false (white)
- auto_threshold() pipeline: grayscale → otsu → binary in one call
- Binary conversion completes in <5ms per tech spec budget

AC4: Brightness/Contrast/Gamma Adjustments
- adjust_brightness() function scales pixel values by factor (0.0-2.0)
- adjust_contrast() function adjusts contrast by factor (0.0-2.0)
- adjust_gamma() function applies gamma correction (0.1-3.0)
- Adjustments applied before thresholding for optimal results
- Pixel values clamped to 0-255 range after adjustments

AC5: Integration with Image Pipeline
- Works with DynamicImage from Story 3.2 resize output
- Returns BinaryImage compatible with Story 3.4 dithering (or direct to Story 3.5)
- Module located at src/image/threshold.rs
- Conversion functions (convert.rs) separate from threshold functions
- Public API exported from src/image/mod.rs

AC6: Error Handling
- Zero panics guarantee maintained (all functions return Result where appropriate)
- Invalid adjustment factors return DotmaxError::InvalidParameter
- Empty images or invalid dimensions handled gracefully
- Descriptive error messages for debugging

AC7: Testing
- Unit tests for Otsu calculation on known test images with expected thresholds
- Unit tests for grayscale conversion (RGB → luminance formula correctness)
- Unit tests for brightness/contrast/gamma adjustments (pixel value transformations)
- Unit tests for edge cases (all-black, all-white, uniform gray)
- Integration test: load → resize → grayscale → threshold → binary
- Test coverage >80% for threshold module

AC8: Performance Target
- Grayscale conversion: <2ms per tech spec budget
- Otsu threshold calculation: <5ms per tech spec budget
- Total threshold pipeline: <10ms for 160×96 pixels (80×24 terminal)
- Benchmarks created with criterion for all operations

AC9: Documentation
- Rustdoc comments for all public functions with examples
- Otsu's method algorithm documented with references
- Brightness/contrast/gamma adjustment formulas documented
- Example program demonstrating grayscale conversion and thresholding
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <artifact>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Functional Requirements: 2D Image Rendering</section>
        <snippet>FR14: The system converts grayscale/color images to braille dot patterns using threshold algorithms. FR18: The system applies Otsu thresholding for optimal binary conversion. FR19: Developers can adjust brightness/contrast/gamma of images before rendering.</snippet>
      </artifact>
      <artifact>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Non-Functional Requirements: Performance</section>
        <snippet>NFR-P1: Image-to-braille conversion <25ms target, <50ms maximum for standard terminals (80×24). Total pipeline must complete within performance budget with stage-by-stage allocation.</snippet>
      </artifact>
      <artifact>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Pattern 2: Image-to-Braille Conversion Pipeline</section>
        <snippet>Pipeline stages: Load → Resize → Grayscale → Dither → Threshold → Map to Braille. Grayscale conversion module (convert.rs) transforms RGB to luminance. Threshold module (threshold.rs) implements Otsu algorithm and binary conversion. Each stage independently testable and optimizable.</snippet>
      </artifact>
      <artifact>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Error Handling Pattern (ADR 0002)</section>
        <snippet>Use thiserror for custom error types with DotmaxError enum. All public functions return Result<T, DotmaxError>. Zero panics guarantee: all panics are bugs. InvalidParameter variant for adjustment factor validation with descriptive errors.</snippet>
      </artifact>
      <artifact>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification</title>
        <section>Data Models and Contracts</section>
        <snippet>BinaryImage struct: width, height, pixels: Vec<bool> (true = black, false = white). Pipeline: DynamicImage → GrayImage → BinaryImage → BrailleGrid. Grayscale uses ITU-R BT.601 luminance: Y = 0.299*R + 0.587*G + 0.114*B.</snippet>
      </artifact>
      <artifact>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification</title>
        <section>Performance: Per-Stage Budget Allocation</section>
        <snippet>Grayscale conversion: <2ms target. Brightness/contrast/gamma: <3ms target (optional stage). Otsu threshold calculation: <5ms target. Binary conversion (apply_threshold): <2ms target. Total Story 3.3: <10ms cumulative for full threshold pipeline.</snippet>
      </artifact>
      <artifact>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification</title>
        <section>APIs and Interfaces: threshold.rs Function Signatures</section>
        <snippet>to_grayscale(image: &DynamicImage) -> GrayImage; otsu_threshold(gray: &GrayImage) -> u8; apply_threshold(gray: &GrayImage, threshold: u8) -> BinaryImage; auto_threshold(image: &DynamicImage) -> BinaryImage; adjust_brightness/contrast/gamma functions with factor validation.</snippet>
      </artifact>
      <artifact>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification</title>
        <section>Services and Modules</section>
        <snippet>src/image/convert.rs - Color to grayscale conversion. src/image/threshold.rs - Otsu thresholding, brightness/contrast/gamma adjustments, binary conversion. Module organization: conversion functions separate from threshold functions for clarity.</snippet>
      </artifact>
    </docs>
    <code>
      <artifact>
        <path>src/error.rs</path>
        <kind>error types</kind>
        <symbol>DotmaxError</symbol>
        <lines>1-250</lines>
        <reason>Error enum with thiserror. Need to add InvalidParameter variant for brightness/contrast/gamma validation. Pattern: descriptive errors with context (dimensions, values, ranges). Zero panics policy established.</reason>
      </artifact>
      <artifact>
        <path>src/image/mod.rs</path>
        <kind>module</kind>
        <symbol>N/A</symbol>
        <lines>1-67</lines>
        <reason>Public API surface for image module. Currently exports loader and resize. Need to add: pub mod convert; pub mod threshold; pub use convert::to_grayscale; pub use threshold::{BinaryImage, otsu_threshold, apply_threshold, auto_threshold, adjust_brightness, adjust_contrast, adjust_gamma}. Feature gate: #[cfg(feature = "image")].</reason>
      </artifact>
      <artifact>
        <path>src/image/resize.rs</path>
        <kind>module</kind>
        <symbol>resize_to_terminal, resize_to_dimensions</symbol>
        <lines>1-679</lines>
        <reason>Story 3.2 implementation pattern to follow. Uses DynamicImage → DynamicImage pipeline. Comprehensive testing (25+ unit tests). Tracing integration (debug! logs). Helper functions for complex math (calculate_fit_dimensions). Edge case testing critical. Performance budget discipline (<10ms target, documented). Const values for clarity (BRAILLE_CELL_WIDTH, BRAILLE_CELL_HEIGHT). Error context improves DX (includes dimensions in error messages).</reason>
      </artifact>
      <artifact>
        <path>src/image/loader.rs</path>
        <kind>module</kind>
        <symbol>load_from_path, load_from_bytes</symbol>
        <lines>N/A</lines>
        <reason>Story 3.1 implementation provides DynamicImage input to our pipeline. Image loading precedent for error handling (DotmaxError::ImageLoad with path and source). Format support: PNG, JPG, GIF, BMP, WebP, TIFF via image crate.</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <package name="image" version="0.25" features="[]">Industry standard Rust image library. Provides DynamicImage, GrayImage (Luma8), RgbImage types. DynamicImage::to_luma8() for grayscale conversion (built-in luminance formula). Feature-gated behind "image" feature flag.</package>
        <package name="imageproc" version="0.24" features="[]">Image processing algorithms. Check for imageproc::threshold::otsu_level() function. If available, use for Otsu implementation. If not, implement from scratch per Otsu paper. Feature-gated behind "image" feature flag.</package>
        <package name="tracing" version="0.1" features="[]">Structured logging for debug/info logs. Use debug! for detailed flow (Otsu threshold value, adjustment factors). Use info! for major operations (grayscale conversion complete). Instrument functions with #[instrument].</package>
        <package name="thiserror" version="2.0" features="[]">Error handling derive macros. Add InvalidParameter variant to DotmaxError with format: "Invalid {parameter}: {value} (valid range: {min}-{max})". Use #[error(...)] attribute for descriptive messages.</package>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
**Zero Panics Policy (ADR 0002):**
- All public functions return Result<T, DotmaxError>
- Never use .unwrap() or .expect() in production code
- All edge cases handled gracefully (all-black, all-white, uniform gray images)
- Parameter validation before processing (brightness 0.0-2.0, contrast 0.0-2.0, gamma 0.1-3.0)

**Performance Budget (Tech Spec):**
- Grayscale conversion: <2ms (simple pixel-wise luminance calculation)
- Brightness/contrast/gamma: <3ms each (optional adjustments, pixel-wise operations)
- Otsu threshold calculation: <5ms (histogram + variance iteration over 256 thresholds)
- Binary conversion (apply_threshold): <2ms (simple comparison per pixel)
- Total Story 3.3 pipeline: <10ms cumulative target
- Measure each operation separately with criterion.rs benchmarks
- Optimize only if benchmarks show targets missed (measure-first approach per ADR 0007)

**Module Structure (Architecture Pattern):**
- src/image/convert.rs - Grayscale conversion only (Color → grayscale transformation)
- src/image/threshold.rs - Otsu, binary conversion, adjustments, BinaryImage type
- Separate concerns: conversion vs. thresholding for clarity and testability
- Feature gate: All code behind #[cfg(feature = "image")]

**Testing Requirements (NFR-M4):**
- Core threshold module: >80% line coverage
- Unit tests for all functions (grayscale, Otsu, adjustments, binary conversion)
- Edge case tests (all-black, all-white, uniform gray, 1×1 image)
- Integration tests for full pipeline (load → resize → grayscale → threshold)
- Benchmarks validate performance targets (<2ms grayscale, <5ms Otsu, <10ms total)
- Visual regression tests (save output, compare against baseline)

**Code Quality Standards (Story 3.2 precedent):**
- Clippy clean with -D warnings (zero warnings mandatory)
- Rustfmt formatted automatically
- Comprehensive inline documentation with examples (rustdoc for all public functions)
- All doctests compile and pass (tested in CI)

**Error Messages (Architecture Pattern):**
- Include context in errors: threshold values, adjustment factors, dimensions
- Format: "Invalid brightness factor: 3.5 (valid range: 0.0-2.0)"
- Actionable: explain what went wrong and valid range
- Use thiserror #[error(...)] attribute for consistency

**Logging Strategy (Architecture Pattern):**
- info! - Major operations (grayscale conversion complete, threshold calculated)
- debug! - Detailed flow (Otsu threshold value, adjustment factors applied)
- Use #[instrument] for function-level tracing
- Follow pattern from resize.rs (lines 151-177)

**Image Pipeline Integration:**
- Input: DynamicImage from Story 3.2 (resize output)
- Output: BinaryImage (boolean pixels) → passes to Story 3.4 (dithering) OR Story 3.5 (mapper)
- Pipeline sequence: Load (3.1) → Resize (3.2) → Grayscale (3.3) → [Dither (3.4)] → Threshold (3.3) → Map (3.5)
- Note: Dithering (3.4) is optional - images can go directly from threshold to mapper

**Data Type Contracts:**
- DynamicImage: Multi-format image container from image crate
- GrayImage: 8-bit grayscale (ImageBuffer<Luma<u8>, Vec<u8>>) from image crate
- BinaryImage: Custom struct with width: u32, height: u32, pixels: Vec<bool> (true = black, false = white)
- Luminance formula (ITU-R BT.601): Y = 0.299*R + 0.587*G + 0.114*B (built into DynamicImage::to_luma8())

**Otsu's Method Algorithm (Tech Spec):**
- Industry standard for automatic thresholding (Nobuyuki Otsu, 1979)
- Maximizes between-class variance (separability of foreground/background)
- Steps: 1) Calculate histogram (256 bins for 0-255 pixel values), 2) For each threshold (0-255): calculate class weights, means, between-class variance, 3) Return threshold with maximum variance
- Edge cases: uniform images return the uniform value
- Reference: Otsu, N. (1979). "A Threshold Selection Method from Gray-Level Histograms". IEEE Transactions on Systems, Man, and Cybernetics. 9(1): 62–66.

**Adjustment Formulas (Dev Notes):**
- Brightness (multiplicative): new_pixel = clamp(old_pixel * factor, 0, 255). Factor 0.0 = black, 1.0 = unchanged, 2.0 = double brightness.
- Contrast (pivot around midpoint): new_pixel = clamp((old_pixel - 128) * factor + 128, 0, 255). Factor 0.0 = uniform gray (128), 1.0 = unchanged, 2.0 = double contrast.
- Gamma (nonlinear power curve): new_pixel = 255 * (old_pixel / 255)^gamma. Gamma < 1.0 = brightens, Gamma > 1.0 = darkens.
  </constraints>

  <interfaces>
    <interface>
      <name>DynamicImage::to_luma8()</name>
      <kind>method from image crate</kind>
      <signature>pub fn to_luma8(&self) -> ImageBuffer<Luma<u8>, Vec<u8>></signature>
      <path>External: image crate</path>
      <description>Standard grayscale conversion with built-in luminance formula (Y = 0.299*R + 0.587*G + 0.114*B). Use this for grayscale conversion in to_grayscale() function.</description>
    </interface>
    <interface>
      <name>imageproc::threshold::otsu_level</name>
      <kind>function from imageproc crate (check availability)</kind>
      <signature>pub fn otsu_level(image: &GrayImage) -> u8</signature>
      <path>External: imageproc crate (if available in v0.24)</path>
      <description>Otsu threshold calculation. Check if this function exists in imageproc 0.24. If available, use it. If not, implement from scratch following Otsu's algorithm.</description>
    </interface>
    <interface>
      <name>BrailleGrid::set_dot()</name>
      <kind>method from Epic 2</kind>
      <signature>pub fn set_dot(&mut self, x: usize, y: usize, value: bool) -> Result<(), DotmaxError></signature>
      <path>src/grid.rs (Epic 2)</path>
      <description>Story 3.5 (mapper) will use this to map BinaryImage pixels to braille dots. Not directly used in Story 3.3, but BinaryImage output is designed for this interface.</description>
    </interface>
    <interface>
      <name>DotmaxError::InvalidParameter</name>
      <kind>error variant to add</kind>
      <signature>#[error("Invalid {parameter_name}: {value} (valid range: {min}-{max})")] InvalidParameter { parameter_name: String, value: String, min: String, max: String }</signature>
      <path>src/error.rs</path>
      <description>Add this variant to DotmaxError enum for validating brightness/contrast/gamma factors. Use for clear, actionable error messages.</description>
    </interface>
    <interface>
      <name>resize_to_terminal()</name>
      <kind>function from Story 3.2</kind>
      <signature>pub fn resize_to_terminal(image: &DynamicImage, term_width: u16, term_height: u16) -> Result<DynamicImage, DotmaxError></signature>
      <path>src/image/resize.rs</path>
      <description>Provides properly-sized images (e.g., 160×96 for 80×24 terminal) as input to grayscale conversion. Integration point for pipeline.</description>
    </interface>
    <interface>
      <name>resize_to_dimensions()</name>
      <kind>function from Story 3.2</kind>
      <signature>pub fn resize_to_dimensions(image: &DynamicImage, target_width: u32, target_height: u32, preserve_aspect: bool) -> Result<DynamicImage, DotmaxError></signature>
      <path>src/image/resize.rs</path>
      <description>Use for creating test images of specific sizes in unit tests. Pattern for aspect ratio preservation.</description>
    </interface>
  </interfaces>

  <tests>
    <standards>
**Testing Framework:** Rust standard test framework with #[test] attribute. Integration tests in tests/ directory. Unit tests in #[cfg(test)] mod tests blocks within source files.

**Test Organization:** Unit tests co-located with implementation (src/image/convert.rs, src/image/threshold.rs #[cfg(test)] sections). Integration tests in tests/image_loading_tests.rs or new file. Benchmarks in benches/image_conversion.rs.

**Test Patterns from Story 3.2:**
- Helper functions for test image creation (create_test_image(width, height))
- Edge case testing critical (zero dimensions, extreme values, uniform images)
- Property-based testing where applicable (all thresholds in range 0-255)
- Known value testing (pure red/green/blue → expected gray values)
- Performance validation in benchmarks (<2ms grayscale, <5ms Otsu targets)

**Assertion Strategy:**
- Use assert_eq! for exact matches (dimensions, threshold values)
- Use assert! with tolerance for floating point (aspect ratios, gamma calculations)
- Use matches! for error variant matching (InvalidParameter, InvalidImageDimensions)
- Use Result::is_ok() / Result::is_err() for error path testing

**Test Coverage Target:** >80% line coverage for convert.rs and threshold.rs modules (NFR-M4). Critical paths (Otsu algorithm, adjustment formulas) should have 100% coverage.

**CI Integration:** All tests run on cargo test --features image. Clippy enforced with -D warnings. Rustfmt check. Benchmarks run on merge to main for performance regression detection.
    </standards>
    <locations>
- src/image/convert.rs - Unit tests in #[cfg(test)] mod tests section
- src/image/threshold.rs - Unit tests in #[cfg(test)] mod tests section
- tests/image_loading_tests.rs - Integration tests for full pipeline (load → resize → grayscale → threshold)
- benches/image_conversion.rs - Performance benchmarks (or create benches/image_threshold.rs)
- examples/threshold_demo.rs - Example program (also serves as integration test)
    </locations>
    <ideas>
**Unit Test Ideas (Grayscale Conversion):**
- test_to_grayscale_pure_red → Verify (255, 0, 0) converts to ~76 (0.299 * 255)
- test_to_grayscale_pure_green → Verify (0, 255, 0) converts to ~150 (0.587 * 255)
- test_to_grayscale_pure_blue → Verify (0, 0, 255) converts to ~29 (0.114 * 255)
- test_to_grayscale_white → Verify (255, 255, 255) converts to 255
- test_to_grayscale_black → Verify (0, 0, 0) converts to 0
- test_to_grayscale_already_gray → Verify GrayImage passes through unchanged
- test_to_grayscale_mixed_colors → Test various RGB combinations for formula correctness

**Unit Test Ideas (Otsu Threshold):**
- test_otsu_all_black → All pixels value 0 → threshold should be 0 or low
- test_otsu_all_white → All pixels value 255 → threshold should be 255 or high
- test_otsu_uniform_gray → All pixels value 128 → threshold should be ~128
- test_otsu_bimodal_distribution → Half black (0), half white (255) → threshold ~127-128
- test_otsu_known_image → Use image with documented Otsu threshold value (validate correctness)
- test_otsu_edge_case_1x1 → Single pixel image
- test_otsu_large_image_performance → 1000×1000 image completes in <5ms
- test_otsu_threshold_range → All outputs in range 0-255

**Unit Test Ideas (Brightness/Contrast/Gamma):**
- test_brightness_darkens → Factor 0.5 reduces pixel values
- test_brightness_brightens → Factor 1.5 increases pixel values
- test_brightness_no_op → Factor 1.0 leaves pixels unchanged
- test_brightness_invalid_factor_low → Factor -0.5 returns InvalidParameter error
- test_brightness_invalid_factor_high → Factor 3.0 returns InvalidParameter error
- test_contrast_reduces → Factor 0.5 moves values closer to 128
- test_contrast_increases → Factor 1.5 spreads values from 128
- test_contrast_no_op → Factor 1.0 leaves pixels unchanged
- test_gamma_brightens → Gamma 0.5 brightens image (nonlinear)
- test_gamma_darkens → Gamma 2.0 darkens image
- test_gamma_no_op → Gamma 1.0 leaves pixels unchanged

**Unit Test Ideas (Binary Conversion):**
- test_apply_threshold_simple → 2×2 test pattern, threshold 128, verify pixel mapping
- test_apply_threshold_all_above → All pixels above threshold → all true (black)
- test_apply_threshold_all_below → All pixels below threshold → all false (white)
- test_auto_threshold_pipeline → DynamicImage → auto_threshold → BinaryImage (end-to-end)

**Integration Test Ideas (Full Pipeline):**
- test_pipeline_load_resize_grayscale_threshold → Load PNG → resize to 80×24 → grayscale → threshold → verify BinaryImage
- test_pipeline_with_brightness → Load → resize → grayscale → adjust brightness → threshold → compare results
- test_pipeline_with_contrast → Load → resize → grayscale → adjust contrast → threshold → compare results
- test_pipeline_with_gamma → Load → resize → grayscale → adjust gamma → threshold → compare results
- test_pipeline_chained_adjustments → Brightness + contrast + gamma → threshold → verify combined effect
- test_error_handling_invalid_parameters → Test all adjustment functions with invalid factors return errors (not panics)

**Benchmark Ideas (criterion.rs):**
- bench_grayscale_conversion_160x96 → Measure time for terminal-sized image
- bench_otsu_threshold_160x96 → Measure Otsu calculation time
- bench_apply_threshold_160x96 → Measure binary conversion time
- bench_auto_threshold_pipeline → Full pipeline (grayscale → otsu → binary)
- bench_brightness_adjustment → Measure adjustment operation time
- bench_contrast_adjustment → Measure adjustment operation time
- bench_gamma_correction → Measure gamma operation time
- Validate: grayscale <2ms, Otsu <5ms, total <10ms targets
    </ideas>
  </tests>
</story-context>
