<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.1</storyId>
    <title>Implement Image Loading from File Paths and Byte Buffers</title>
    <status>drafted</status>
    <generatedAt>2025-11-19</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/3-1-implement-image-loading-from-file-paths-and-byte-buffers.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>dotmax library user</asA>
    <iWant>to load images from file paths and byte buffers in multiple formats (PNG, JPG, GIF, BMP, WebP, TIFF)</iWant>
    <soThat>I can provide image data to the braille rendering pipeline from various sources</soThat>
    <tasks>
- [ ] **Task 1: Set up `image` feature and module structure** (AC: 5)
  - [ ] 1.1: Add `image = { version = "0.25", optional = true }` to Cargo.toml dependencies
  - [ ] 1.2: Add `image = ["dep:image"]` to [features] section in Cargo.toml
  - [ ] 1.3: Create `src/image/mod.rs` with `#[cfg(feature = "image")]` gate
  - [ ] 1.4: Create `src/image/loader.rs` with module structure
  - [ ] 1.5: Add `pub mod image;` to `src/lib.rs` with feature gate
  - [ ] 1.6: Test compilation with and without feature: `cargo build` and `cargo build --features image`

- [ ] **Task 2: Extend `DotmaxError` with image-specific variants** (AC: 4)
  - [ ] 2.1: Add `ImageLoad { path: PathBuf, source: image::ImageError }` variant to `src/error.rs`
  - [ ] 2.2: Add `UnsupportedFormat { format: String }` variant
  - [ ] 2.3: Add `InvalidImageDimensions { width: u32, height: u32 }` variant
  - [ ] 2.4: Implement `#[error]` messages for each variant using thiserror
  - [ ] 2.5: Test error Display output includes helpful context

- [ ] **Task 3: Implement `load_from_path()` function** (AC: 1, 6)
  - [ ] 3.1: Implement signature: `pub fn load_from_path(path: &Path) -> Result&lt;DynamicImage, DotmaxError&gt;`
  - [ ] 3.2: Validate path exists using `std::fs::metadata()`
  - [ ] 3.3: Call `image::open(path)` and convert `ImageError` to `DotmaxError::ImageLoad`
  - [ ] 3.4: Validate dimensions against MAX_IMAGE_WIDTH/HEIGHT constants (10,000×10,000)
  - [ ] 3.5: Return `InvalidImageDimensions` error if image exceeds limits
  - [ ] 3.6: Add tracing logs: `info!("Loading image from {:?}")` and `debug!("Image dimensions: {}×{}")`

- [ ] **Task 4: Implement `load_from_bytes()` function** (AC: 2)
  - [ ] 4.1: Implement signature: `pub fn load_from_bytes(bytes: &[u8]) -> Result&lt;DynamicImage, DotmaxError&gt;`
  - [ ] 4.2: Call `image::load_from_memory(bytes)` and map errors to `DotmaxError::ImageLoad`
  - [ ] 4.3: Validate dimensions same as `load_from_path()`
  - [ ] 4.4: Add tracing logs for byte buffer loading

- [ ] **Task 5: Implement `supported_formats()` helper** (AC: 3)
  - [ ] 5.1: Implement signature: `pub fn supported_formats() -> Vec&lt;&'static str&gt;`
  - [ ] 5.2: Return `vec!["png", "jpg", "jpeg", "gif", "bmp", "webp", "tiff"]`
  - [ ] 5.3: Add rustdoc explaining format detection is automatic

- [ ] **Task 6: Write unit tests for loader module** (AC: 7)
  - [ ] 6.1: Create `tests/fixtures/images/` directory with test images (sample.png, test_photo.jpg)
  - [ ] 6.2: Test `load_from_path()` with valid PNG file
  - [ ] 6.3: Test `load_from_path()` with valid JPG file
  - [ ] 6.4: Test `load_from_path()` with missing file (expect `ImageLoad` error)
  - [ ] 6.5: Test `load_from_path()` with corrupted PNG (create invalid test fixture)
  - [ ] 6.6: Test `load_from_bytes()` with valid PNG bytes
  - [ ] 6.7: Test `load_from_bytes()` with invalid bytes
  - [ ] 6.8: Test dimension validation (create 10,001×1 test image)
  - [ ] 6.9: Test `supported_formats()` returns correct list
  - [ ] 6.10: Run tests on all platforms in CI

- [ ] **Task 7: Write integration tests** (AC: 7)
  - [ ] 7.1: Create `tests/image_loading_tests.rs` with `#[cfg(feature = "image")]` gate
  - [ ] 7.2: Integration test: Load PNG, verify DynamicImage width/height
  - [ ] 7.3: Integration test: Load JPG, verify format detection
  - [ ] 7.4: Integration test: Load all supported formats in sequence
  - [ ] 7.5: Integration test: Error handling end-to-end (missing file returns error, not panic)

- [ ] **Task 8: Add documentation and examples** (AC: 8)
  - [ ] 8.1: Add module-level rustdoc to `src/image/mod.rs` explaining feature gate and usage
  - [ ] 8.2: Add function-level rustdoc with `# Examples` for `load_from_path()`
  - [ ] 8.3: Add function-level rustdoc with `# Examples` for `load_from_bytes()`
  - [ ] 8.4: Add `# Errors` section to rustdoc explaining each error variant
  - [ ] 8.5: Create `examples/load_image.rs` demonstrating file and byte buffer loading
  - [ ] 8.6: Test that example compiles: `cargo run --example load_image --features image`

- [ ] **Task 9: Validation and cleanup** (AC: All)
  - [ ] 9.1: Run `cargo test --features image` - all tests pass
  - [ ] 9.2: Run `cargo clippy --features image -- -D warnings` - no warnings
  - [ ] 9.3: Run `cargo fmt` - code formatted
  - [ ] 9.4: Test core library still compiles without feature: `cargo build` (no `--features`)
  - [ ] 9.5: Verify zero panics guarantee (grep for `.unwrap()`, `.expect()` in loader code)
  - [ ] 9.6: Run visual check: example program loads and displays image metadata
    </tasks>
  </story>

  <acceptanceCriteria>
1. **Image Loading from File Paths**
   - [ ] `load_from_path()` function loads valid image files from disk
   - [ ] Supported formats: PNG, JPG, GIF, BMP, WebP, TIFF
   - [ ] Returns `DynamicImage` type from `image` crate
   - [ ] Returns `DotmaxError::ImageLoad` for missing files
   - [ ] Returns `DotmaxError::ImageLoad` for corrupted files
   - [ ] Returns `DotmaxError::UnsupportedFormat` for unsupported formats

2. **Image Loading from Byte Buffers**
   - [ ] `load_from_bytes()` function loads images from memory buffers
   - [ ] Supports all same formats as file loading
   - [ ] Returns `DynamicImage` from valid byte arrays
   - [ ] Returns appropriate errors for invalid byte data

3. **Format Detection**
   - [ ] `supported_formats()` function returns list of supported format extensions
   - [ ] Format detection is automatic (relies on `image` crate)
   - [ ] Clear error messages indicate which format was expected/detected

4. **Error Handling**
   - [ ] Zero panics guarantee maintained (all operations return `Result`)
   - [ ] `DotmaxError` extended with `ImageLoad`, `UnsupportedFormat`, `InvalidImageDimensions` variants
   - [ ] Error messages include file path context for debugging
   - [ ] Error source chain preserved from `image` crate errors

5. **Feature Gating**
   - [ ] All image loading code behind `image` feature flag
   - [ ] `src/image/mod.rs` and `src/image/loader.rs` created
   - [ ] Feature compiles independently: `cargo build --features image`
   - [ ] Core library still compiles without `image` feature
   - [ ] Public API exports `ImageLoader` types when feature enabled

6. **Input Validation**
   - [ ] Maximum image dimensions enforced (10,000×10,000 pixels default)
   - [ ] File size limits prevent memory exhaustion attacks
   - [ ] Path validation ensures file exists and is readable
   - [ ] Returns `DotmaxError::InvalidImageDimensions` for oversized images

7. **Testing**
   - [ ] Unit tests for valid image loading (all supported formats)
   - [ ] Unit tests for error conditions (missing file, corrupted data, unsupported format)
   - [ ] Integration test loads actual PNG/JPG test fixtures
   - [ ] Test coverage &gt;80% for loader module
   - [ ] Tests pass on all platforms (Windows, Linux, macOS)

8. **Documentation**
   - [ ] Rustdoc comments for all public functions
   - [ ] Example code showing file and byte buffer loading
   - [ ] Supported formats list documented in module docs
   - [ ] Error handling examples included
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification - 2D Image Rendering Pipeline</title>
        <section>Module Design - src/image/loader.rs</section>
        <snippet>Responsible for loading images from files/memory, converting to DynamicImage. Inputs: File paths, byte buffers. Outputs: DynamicImage from image crate. Uses image crate v0.25 (industry standard, 100M+ downloads). Supports PNG, JPG, GIF, BMP, WebP, TIFF formats.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification - Error Handling</title>
        <section>APIs and Interfaces - Error Additions to src/error.rs</section>
        <snippet>ImageLoad variant with path and source chain preservation. UnsupportedFormat variant for format errors. InvalidImageDimensions variant for oversized images. Uses thiserror for error messages with context.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification - Performance Targets</title>
        <section>Non-Functional Requirements - Performance Budget</section>
        <snippet>Image loading budget: &lt;5ms target (disk I/O primary bottleneck). Cached after first load. Minimal processing at load stage (just decode). Memory efficiency: DynamicImage size depends on dimensions.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification - Security Requirements</title>
        <section>Non-Functional Requirements - Input Validation</section>
        <snippet>File path validation before loading. Maximum image dimensions: 10,000×10,000 pixels to prevent OOM attacks. Format validation relies on image crate's robust error handling. All decode errors caught and converted to DotmaxError::ImageLoad.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>dotmax Architecture - Feature Flag Architecture</title>
        <section>ADR 0003: Feature Flag Architecture</section>
        <snippet>Core rendering lightweight, but users need image/SVG support. Use Cargo feature flags for optional capabilities. Core has zero optional dependencies. Image/SVG/video/3D are opt-in. Keeps core library minimal (&lt;2MB binary size).</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>dotmax Architecture - Error Handling Pattern</title>
        <section>ADR 0002: Use thiserror for Error Handling</section>
        <snippet>Library needs clear error types for users to handle different error conditions. Use thiserror for custom error types with DotmaxError enum. Type-safe error matching for users. Minimal boilerplate with derive macro. Clear error context and chaining.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/epic-2-retro-2025-11-19.md</path>
        <title>Epic 2 Retrospective - Learnings for Epic 3</title>
        <section>Action Items from Epic 2</section>
        <snippet>Continue Zero Panics Discipline (all image pipeline operations return Result). Maintain Empirical Testing Mindset (trust data over assumptions). Document edge cases in code with inline comments. Visual validation required alongside unit tests.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/error.rs</path>
        <kind>module</kind>
        <symbol>DotmaxError</symbol>
        <lines>1-177</lines>
        <reason>Existing error type enum that needs extension with ImageLoad, UnsupportedFormat, and InvalidImageDimensions variants. Uses thiserror for error handling pattern established in Epic 2.</reason>
      </artifact>
      <artifact>
        <path>src/lib.rs</path>
        <kind>module</kind>
        <symbol>lib</symbol>
        <lines>1-88</lines>
        <reason>Public API surface where image module will be conditionally exported using #[cfg(feature = "image")]. Shows existing feature gate pattern and re-export structure.</reason>
      </artifact>
      <artifact>
        <path>tests/integration_tests.rs</path>
        <kind>test</kind>
        <symbol>integration_tests</symbol>
        <lines>all</lines>
        <reason>Existing integration test structure showing testing patterns (unit tests in #[cfg(test)] blocks). Story 3.1 will add tests/image_loading_tests.rs following this pattern with #[cfg(feature = "image")] gate.</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <package name="image" version="0.25" optional="true">Industry standard Rust image library (100M+ downloads). Handles PNG, JPG, GIF, BMP, WebP, TIFF decoding. Returns DynamicImage unified container. Feature-gated dependency.</package>
        <package name="imageproc" version="0.24" optional="true">Image processing companion library. Not needed for Story 3.1 (loader only), but part of image feature gate for future stories (thresholding, filtering).</package>
        <package name="thiserror" version="2.0">Error handling with derive macros. Already in use for DotmaxError. Needed to extend with ImageLoad, UnsupportedFormat, InvalidImageDimensions variants.</package>
        <package name="tracing" version="0.1">Structured logging. Already integrated in Epic 2. Story 3.1 will add info!/debug! logs for image loading operations.</package>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>**Feature Flag Architecture (ADR 0003):** All image loading code MUST be behind `image` feature flag. Core library compiles without --features image. Binary size target: Core &lt;2MB without image features.</constraint>
    <constraint>**Zero Panics Policy (Epic 2):** All public functions return Result&lt;T, DotmaxError&gt;. No .unwrap() or .expect() in public API code. Grep verification required in Task 9.5.</constraint>
    <constraint>**Error Handling Pattern (ADR 0002):** Use thiserror for error variants. Preserve source chain from image crate errors using #[source] attribute. Error messages must include context (file path, dimensions) for debugging.</constraint>
    <constraint>**Maximum Image Dimensions (NFR-S2):** Enforce 10,000×10,000 pixel limit to prevent OOM attacks. Return DotmaxError::InvalidImageDimensions for oversized images. Validate after decoding in both load_from_path() and load_from_bytes().</constraint>
    <constraint>**Logging Strategy:** Use tracing crate with info! for major operations, debug! for detailed flow. Follow Epic 2 pattern. Library does NOT initialize subscriber (user's responsibility).</constraint>
    <constraint>**Testing Requirements:** Unit tests in #[cfg(test)] blocks within modules. Integration tests in tests/ directory with #[cfg(feature = "image")] gate. Test fixtures in tests/fixtures/images/. Coverage target &gt;80% for loader module.</constraint>
    <constraint>**Cross-Platform Compatibility:** Tests must pass on Windows, Linux, macOS. CI matrix already configured from Epic 1. No platform-specific code in loader (image crate handles platform differences).</constraint>
    <constraint>**Performance Target (NFR-P1):** Image loading &lt;5ms target. Disk I/O is bottleneck. Minimal processing at load stage (decode only, no resizing/conversion). Story 3.1 establishes baseline, Epic 7 will benchmark.</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>load_from_path</name>
      <kind>function</kind>
      <signature>pub fn load_from_path(path: &amp;Path) -&gt; Result&lt;DynamicImage, DotmaxError&gt;</signature>
      <path>src/image/loader.rs</path>
      <description>Primary interface for loading images from filesystem. Validates path exists, decodes image using image crate, validates dimensions against MAX_IMAGE_WIDTH/HEIGHT (10,000×10,000), returns DynamicImage or error.</description>
    </interface>
    <interface>
      <name>load_from_bytes</name>
      <kind>function</kind>
      <signature>pub fn load_from_bytes(bytes: &amp;[u8]) -&gt; Result&lt;DynamicImage, DotmaxError&gt;</signature>
      <path>src/image/loader.rs</path>
      <description>Interface for loading images from memory buffers (e.g., embedded images, network data). Calls image::load_from_memory(), validates dimensions, returns DynamicImage or error. Same dimension limits as load_from_path().</description>
    </interface>
    <interface>
      <name>supported_formats</name>
      <kind>function</kind>
      <signature>pub fn supported_formats() -&gt; Vec&lt;&amp;'static str&gt;</signature>
      <path>src/image/loader.rs</path>
      <description>Helper function returning list of supported format extensions: ["png", "jpg", "jpeg", "gif", "bmp", "webp", "tiff"]. Used for documentation and user validation. Format detection is automatic (image crate determines format from file magic bytes).</description>
    </interface>
    <interface>
      <name>DotmaxError::ImageLoad</name>
      <kind>error variant</kind>
      <signature>ImageLoad { path: PathBuf, #[source] source: image::ImageError }</signature>
      <path>src/error.rs</path>
      <description>Error variant for image loading failures. Includes file path for debugging context. Preserves source chain from image crate's ImageError for detailed error propagation. Used by both load_from_path() and load_from_bytes().</description>
    </interface>
    <interface>
      <name>DotmaxError::InvalidImageDimensions</name>
      <kind>error variant</kind>
      <signature>InvalidImageDimensions { width: u32, height: u32 }</signature>
      <path>src/error.rs</path>
      <description>Error variant for images exceeding maximum dimensions (10,000×10,000 pixels). Includes actual dimensions in error message for user feedback. Security feature to prevent OOM attacks.</description>
    </interface>
    <interface>
      <name>DynamicImage</name>
      <kind>external type</kind>
      <signature>image::DynamicImage</signature>
      <path>image crate v0.25</path>
      <description>External type from image crate. Unified container for all image formats. Provides .width(), .height(), .to_rgb8(), .to_luma8() methods. Used as return type for load functions and input type for future resize/convert functions (Stories 3.2, 3.3).</description>
    </interface>
  </interfaces>

  <tests>
    <standards>
**Testing Standards from Epic 2:**
- Unit tests in #[cfg(test)] modules within source files
- Integration tests in separate tests/ directory files
- Test fixtures in tests/fixtures/ subdirectories
- Feature-gated tests use #[cfg(feature = "image")] attribute
- Zero panics guarantee: All error paths return Result, not panic
- Coverage target: &gt;80% line coverage for loader module
- CI runs tests on Windows, Linux, macOS with stable Rust and MSRV (1.70)

**Image Loading Specific Standards:**
- Test all supported formats: PNG, JPG, GIF, BMP, WebP, TIFF
- Test both success paths (valid images) and error paths (missing, corrupted, oversized)
- Use actual image files in tests/fixtures/images/ (not mocks)
- Validate DynamicImage dimensions match expected values
- Test dimension validation edge case: exactly 10,000×10,000 (ok), 10,001×1 (error)
    </standards>
    <locations>
      <location>src/image/loader.rs - Unit tests in #[cfg(test)] module</location>
      <location>tests/image_loading_tests.rs - Integration tests with #[cfg(feature = "image")]</location>
      <location>tests/fixtures/images/ - Test image files (PNG, JPG, etc.)</location>
    </locations>
    <ideas>
      <idea ac="AC1">Unit test: load_from_path() with valid PNG returns DynamicImage with correct dimensions</idea>
      <idea ac="AC1">Unit test: load_from_path() with missing file returns DotmaxError::ImageLoad with path context</idea>
      <idea ac="AC1">Unit test: load_from_path() with corrupted PNG (invalid header) returns DotmaxError::ImageLoad</idea>
      <idea ac="AC2">Unit test: load_from_bytes() with PNG byte array returns DynamicImage</idea>
      <idea ac="AC2">Unit test: load_from_bytes() with invalid bytes returns DotmaxError::ImageLoad</idea>
      <idea ac="AC3">Unit test: supported_formats() returns vec!["png", "jpg", "jpeg", "gif", "bmp", "webp", "tiff"]</idea>
      <idea ac="AC4">Unit test: Error Display includes file path for ImageLoad variant</idea>
      <idea ac="AC4">Unit test: Error Display includes dimensions for InvalidImageDimensions variant</idea>
      <idea ac="AC5">Integration test: Compile with --features image succeeds, compile without features succeeds</idea>
      <idea ac="AC6">Unit test: load_from_path() with 10,001×1 image returns InvalidImageDimensions error</idea>
      <idea ac="AC6">Unit test: load_from_path() with 10,000×10,000 image succeeds (edge case)</idea>
      <idea ac="AC7">Integration test: Load all supported formats in sequence, verify all succeed</idea>
      <idea ac="AC7">Integration test: Error handling end-to-end - missing file returns error, not panic</idea>
    </ideas>
  </tests>
</story-context>
