<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>2.4</storyId>
    <title>Implement Comprehensive Error Handling System</title>
    <status>drafted</status>
    <generatedAt>2025-11-18</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/2-4-implement-comprehensive-error-handling-system.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer using dotmax in applications</asA>
    <iWant>comprehensive, meaningful error types for all operations</iWant>
    <soThat>I can handle failures gracefully and provide actionable feedback to users</soThat>
    <tasks>
      - Task 1: Create comprehensive DotmaxError enum with all 6 variants (InvalidDimensions, OutOfBounds, InvalidDotIndex, Terminal, TerminalBackend, UnicodeConversion)
      - Task 2: Migrate existing error handling - move DotmaxError from src/grid.rs to src/error.rs module
      - Task 3: Add input validation with proper errors (dimensions, bounds, dot indices)
      - Task 4: Write comprehensive error handling tests (zero dims, out-of-bounds, invalid indices, error context verification)
      - Task 5: Update public API exports (DotmaxError and Result&lt;T&gt; type alias in src/lib.rs)
      - Task 6: Run quality checks and verify zero-panics policy (no unwrap/expect/panic in public API)
    </tasks>
  </story>

  <acceptanceCriteria>
    1. `src/error.rs` contains `DotmaxError` enum with variants: `InvalidDimensions`, `OutOfBounds`, `InvalidDotIndex`, `Terminal`, `TerminalBackend`, `UnicodeConversion`
    2. All error variants use `#[error("...")]` attribute with meaningful, actionable messages
    3. Errors include context: coordinates, dimensions, indices, actual values
    4. I/O errors wrapped via `#[from]` for source preservation
    5. All public API methods return `Result&lt;T, DotmaxError&gt;` - zero panics contract enforced
    6. Unit tests verify error cases: zero dimensions, out-of-bounds access, invalid dot indices
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <artifact>
        <path>docs/sprint-artifacts/tech-spec-epic-2.md</path>
        <title>Epic Technical Specification: Core Braille Rendering Engine</title>
        <section>Story 2.4: Error Handling System</section>
        <snippet>Complete DotmaxError enum specification with 6 variants. Zero panics policy: all public functions return Result&lt;T, DotmaxError&gt;. Input validation requirements: dimensions (width, height &gt; 0, &lt; 10,000), coordinates (x &lt; width, y &lt; height), dot index (0-7). Error messages include coordinates, dimensions, actual values for debugging.</snippet>
      </artifact>
      <artifact>
        <path>docs/sprint-artifacts/tech-spec-epic-2.md</path>
        <title>Epic Technical Specification: Core Braille Rendering Engine</title>
        <section>NFR-S2: Input Validation</section>
        <snippet>MAX_GRID_WIDTH/HEIGHT = 10,000 to prevent OOM attacks. All operations validate bounds before array access. Dimensions validated in BrailleGrid::new(), coordinates in set_dot/get_dot, dot indices 0-7 range check.</snippet>
      </artifact>
      <artifact>
        <path>docs/sprint-artifacts/tech-spec-epic-2.md</path>
        <title>Epic Technical Specification: Core Braille Rendering Engine</title>
        <section>NFR-S3: Zero Panic Policy</section>
        <snippet>Contract: No public API method may panic under any circumstances. All operations return Result&lt;T, DotmaxError&gt;. Enforcement: code review checks for .unwrap()/.expect()/panic!(), unit tests cover edge cases, integration tests stress-test boundary conditions.</snippet>
      </artifact>
      <artifact>
        <path>docs/architecture.md</path>
        <title>Architecture Decision Records</title>
        <section>ADR 0002: Use thiserror for Error Handling</section>
        <snippet>Use thiserror crate for library error types. Provides derive macros for std::error::Error. Advantages: zero boilerplate, source chaining with #[from], custom Display messages. Chosen over anyhow (wrong for libraries) and manual impl (verbose).</snippet>
      </artifact>
      <artifact>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>FR56: Comprehensive Error Handling</section>
        <snippet>Library must provide meaningful error types for all operations. Errors include context (coordinates, dimensions, indices). Support error source chaining for underlying I/O errors.</snippet>
      </artifact>
      <artifact>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>FR57: Zero Panics Policy</section>
        <snippet>No public API method may panic. All operations return Result or panic-free primitives. Contract enforced through testing and code review.</snippet>
      </artifact>
    </docs>
    <code>
      <artifact>
        <path>src/grid.rs</path>
        <kind>module</kind>
        <symbol>DotmaxError</symbol>
        <lines>24-45</lines>
        <reason>EXISTING error enum (partial implementation). Story 2.4 will extract this to src/error.rs and add UnicodeConversion variant. Currently has 5 of 6 required variants.</reason>
      </artifact>
      <artifact>
        <path>src/grid.rs</path>
        <kind>constant</kind>
        <symbol>MAX_GRID_WIDTH, MAX_GRID_HEIGHT</symbol>
        <lines>16-18</lines>
        <reason>Maximum grid dimension constants (10,000) already defined. Used for OOM prevention in BrailleGrid::new() validation.</reason>
      </artifact>
      <artifact>
        <path>src/grid.rs</path>
        <kind>struct</kind>
        <symbol>BrailleGrid</symbol>
        <lines>141-683</lines>
        <reason>Core grid struct that needs comprehensive error handling. Methods to validate: new() (dimensions), set_dot/get_dot (bounds + dot index), clear_region() (bounds), set_cell_color/get_cell_color (bounds).</reason>
      </artifact>
      <artifact>
        <path>src/render.rs</path>
        <kind>module</kind>
        <symbol>TerminalRenderer</symbol>
        <lines>136-326</lines>
        <reason>Uses DotmaxError::Terminal for I/O errors. Already imports from grid module - will need to update import after moving DotmaxError to src/error.rs.</reason>
      </artifact>
      <artifact>
        <path>src/lib.rs</path>
        <kind>module</kind>
        <symbol>public API exports</symbol>
        <lines>1-45</lines>
        <reason>Public API re-exports. Story 2.4 must add: pub use error::DotmaxError; and pub type Result&lt;T&gt; = std::result::Result&lt;T, DotmaxError&gt;;</reason>
      </artifact>
      <artifact>
        <path>tests/integration_tests.rs</path>
        <kind>test</kind>
        <symbol>integration test patterns</symbol>
        <lines>1-201</lines>
        <reason>Existing integration tests use .is_ok() pattern for error checking. Story 2.4 error tests should follow similar patterns with .unwrap_err() and assert!(matches!(...)) for specific variants.</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <package name="thiserror" version="2.0">Error handling derive macros - already in Cargo.toml, Story 2.4 uses for DotmaxError enum</package>
        <package name="ratatui" version="0.29">Terminal UI framework - source of std::io::Error wrapped in DotmaxError::Terminal</package>
        <package name="crossterm" version="0.29">Cross-platform terminal I/O - source of std::io::Error wrapped in DotmaxError::Terminal</package>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    - **Module Organization**: DotmaxError MUST be moved from src/grid.rs (lines 24-45) to new src/error.rs module. Update imports in grid.rs and render.rs to use crate::error::DotmaxError.
    - **Zero Panics Policy (NFR-S3)**: NO .unwrap(), .expect(), or panic!() allowed in public API paths. All public methods return Result&lt;T, DotmaxError&gt; or panic-free primitives.
    - **Error Context (NFR-O2)**: All error variants MUST include context fields for debugging: InvalidDimensions {width, height}, OutOfBounds {x, y, width, height}, InvalidDotIndex {index}, UnicodeConversion {x, y}.
    - **Source Chaining**: Use #[from] attribute for Terminal variant to preserve std::io::Error source chain (already implemented correctly in src/grid.rs:41).
    - **Input Validation (NFR-S2)**:
      - BrailleGrid::new(): width, height &gt; 0 AND width, height &lt;= MAX_GRID_WIDTH/HEIGHT (10,000)
      - set_dot/get_dot: x &lt; width, y &lt; height, dot_index 0-7
      - set_cell_color/get_cell_color: x &lt; width, y &lt; height
      - clear_region: validate region bounds
    - **Testing Standards**: Each error variant MUST have at least one test verifying the error is returned with correct context. Test error Display messages include all context fields.
    - **Backward Compatibility**: Moving DotmaxError to src/error.rs is NOT a breaking change for external users (they import from crate root via lib.rs). Internal modules need import updates only.
  </constraints>

  <interfaces>
    <interface>
      <name>DotmaxError enum</name>
      <kind>Rust error type</kind>
      <signature>
        #[derive(Error, Debug)]
        pub enum DotmaxError {
            #[error("Invalid grid dimensions: width={width}, height={height}")]
            InvalidDimensions { width: usize, height: usize },

            #[error("Out of bounds access: ({x}, {y}) in grid of size ({width}, {height})")]
            OutOfBounds { x: usize, y: usize, width: usize, height: usize },

            #[error("Invalid dot index: {index} (must be 0-7)")]
            InvalidDotIndex { index: u8 },

            #[error("Terminal I/O error: {0}")]
            Terminal(#[from] std::io::Error),

            #[error("Terminal backend error: {0}")]
            TerminalBackend(String),

            #[error("Unicode conversion failed for cell ({x}, {y})")]
            UnicodeConversion { x: usize, y: usize },
        }
      </signature>
      <path>src/error.rs (NEW FILE - create in Story 2.4)</path>
    </interface>
    <interface>
      <name>Result type alias</name>
      <kind>Rust type alias</kind>
      <signature>pub type Result&lt;T&gt; = std::result::Result&lt;T, DotmaxError&gt;;</signature>
      <path>src/lib.rs (add in Story 2.4)</path>
    </interface>
    <interface>
      <name>BrailleGrid::new()</name>
      <kind>Rust method signature</kind>
      <signature>pub fn new(width: usize, height: usize) -&gt; Result&lt;Self, DotmaxError&gt;</signature>
      <path>src/grid.rs:171-235</path>
    </interface>
    <interface>
      <name>BrailleGrid validation methods</name>
      <kind>Rust method signatures</kind>
      <signature>
        pub fn set_dot(&amp;mut self, x: usize, y: usize, dot_index: u8, value: bool) -&gt; Result&lt;(), DotmaxError&gt;
        pub fn get_dot(&amp;self, x: usize, y: usize, dot_index: u8) -&gt; Result&lt;bool, DotmaxError&gt;
        pub fn set_cell_color(&amp;mut self, x: usize, y: usize, color: Color) -&gt; Result&lt;(), DotmaxError&gt;
        pub fn clear_region(&amp;mut self, x: usize, y: usize, width: usize, height: usize) -&gt; Result&lt;(), DotmaxError&gt;
      </signature>
      <path>src/grid.rs (various lines - needs validation added)</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Use Rust's built-in #[test] framework. Follow Arrange-Act-Assert pattern. Error tests use assert!(matches!(result, Err(DotmaxError::VariantName { .. }))). Verify error messages contain context with format!("{}", err) and assert!(msg.contains("expected_value")). Place unit tests in #[cfg(test)] mod tests at end of src/error.rs and src/grid.rs. Run with cargo test, enforce zero warnings with cargo clippy -- -D warnings.
    </standards>
    <locations>
      - src/error.rs (NEW - add #[cfg(test)] mod tests for error message verification, io::Error conversion test)
      - src/grid.rs (EXISTING tests module - add error validation tests for BrailleGrid methods)
      - Tests already exist at src/grid.rs:685+ with 42 passing tests (from Story 2.2)
    </locations>
    <ideas>
      <test ac="1">Create src/error.rs with all 6 DotmaxError variants matching spec exactly</test>
      <test ac="2">Verify each error variant's Display message includes all context fields (width, height, x, y, index)</test>
      <test ac="3">Test InvalidDimensions: BrailleGrid::new(0, 10) and new(10, 0) return Err with correct width/height in error</test>
      <test ac="3">Test InvalidDimensions: BrailleGrid::new(20000, 20000) returns Err (exceeds MAX_GRID_WIDTH/HEIGHT)</test>
      <test ac="3">Test OutOfBounds: set_dot(100, 50, 0, true) on 10x10 grid returns Err with x=100, y=50, width=10, height=10</test>
      <test ac="3">Test InvalidDotIndex: set_dot(5, 5, 10, true) returns Err with index=10</test>
      <test ac="4">Test std::io::Error conversion: create io::Error, convert to DotmaxError via .into(), verify matches Terminal variant</test>
      <test ac="5">Code review scan: search src/ for .unwrap(), .expect(), panic!() in public fn (must be zero occurrences)</test>
      <test ac="6">Run full test suite: cargo test should show all existing tests + new error tests passing (estimate 50+ total tests)</test>
    </ideas>
  </tests>
</story-context>
