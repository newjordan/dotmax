<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.2</storyId>
    <title>Implement Image Resize and Aspect Ratio Preservation</title>
    <status>drafted</status>
    <generatedAt>2025-11-19</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/3-2-implement-image-resize-and-aspect-ratio-preservation.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer rendering images to terminals of varying sizes</asA>
    <iWant>automatic and manual image resizing with aspect ratio preservation</iWant>
    <soThat>images fit terminal dimensions without distortion</soThat>
    <tasks>
      - Task 1: Create resize module structure (AC: 5)
      - Task 2: Implement resize_to_terminal() function (AC: 1)
      - Task 3: Implement resize_to_dimensions() function (AC: 2)
      - Task 4: Implement aspect ratio preservation helpers (AC: 4)
      - Task 5: Implement upscale prevention (optional feature) (AC: 3)
      - Task 6: Handle edge cases (AC: 3, 7)
      - Task 7: Write unit tests (AC: 8)
      - Task 8: Write integration tests (AC: 8)
      - Task 9: Add benchmarks (AC: 6)
      - Task 10: Documentation and examples (AC: 9)
      - Task 11: Validation and cleanup (AC: All)
    </tasks>
  </story>

  <acceptanceCriteria>
    AC1: Automatic Terminal-Based Resizing - resize_to_terminal() calculates optimal dimensions, accounts for braille cells (2×4), preserves aspect ratio, uses Lanczos3 filter
    AC2: Manual Dimension Resizing - resize_to_dimensions() accepts target dimensions, preserve_aspect parameter controls behavior, letterbox/pillarbox when preserving
    AC3: Edge Case Handling - No upscaling by default, downscale when needed, zero/extreme dimensions return InvalidImageDimensions error, handles very wide/tall images
    AC4: Aspect Ratio Math Correctness - ratio = width/height, letterboxing/pillarboxing centered, rounding to whole pixels, unit tests verify math
    AC5: Integration with Image Pipeline - Works with DynamicImage from Story 3.1, output passes to Story 3.3 grayscale, located at src/image/resize.rs
    AC6: Performance Target - Resize completes in less than 10ms for typical images (800×600 → terminal size), Lanczos3 quality documented, bounded memory usage
    AC7: Error Handling - Zero panics guarantee, invalid dimensions return InvalidImageDimensions, terminal (0,0) returns error, extreme ratios handled gracefully
    AC8: Testing - Unit tests for aspect ratio math (16:9, 4:3, 1:1, 21:9), edge case tests, integration tests, visual regression tests, greater than 80% coverage
    AC9: Documentation - Rustdoc comments for all public functions, example code, aspect ratio behavior documented, performance characteristics documented
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification - Image Rendering Pipeline</title>
        <section>APIs and Interfaces - resize.rs</section>
        <snippet>resize_to_terminal(image, term_width, term_height) calculates pixel dimensions from braille cells (width×2, height×4), preserves aspect ratio, uses Lanczos3 filter. resize_to_dimensions(image, target_width, target_height, preserve_aspect) with letterbox/pillarbox support.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification - Image Rendering Pipeline</title>
        <section>Workflows and Sequencing - Step 2: RESIZE</section>
        <snippet>Input: DynamicImage + terminal dimensions (80×24 cells). Calculate pixel dimensions (80×2=160 wide, 24×4=96 tall). Apply aspect ratio preservation (letterbox if needed). Use Lanczos3 filter for quality. Output: terminal-sized DynamicImage.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification - Image Rendering Pipeline</title>
        <section>Performance / Per-Stage Budget Allocation</section>
        <snippet>Resize stage budget: less than 10ms target. Lanczos3 filter is expensive but necessary for quality. Typical case: 800×600 → 160×96 pixels (80×24 terminal). Alternatives: Triangle (faster, lower quality), Nearest (fastest, lowest quality).</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Novel Pattern 1: Braille Dot Matrix Mapping</section>
        <snippet>Braille cell coordinate system - Terminal dimensions in cells: (width, height). Each braille cell = 2×4 dots (2 wide, 4 tall). Pixel dimension calculation: pixels_wide = cells_wide × 2, pixels_tall = cells_tall × 4. Example: 80×24 terminal = 160×96 pixels.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Module Structure - src/image/</section>
        <snippet>src/image/resize.rs - Resizing with aspect ratio preservation. Input: DynamicImage, target dimensions. Output: Resized DynamicImage. Integrates with loader.rs (Story 3.1) and convert.rs (Story 3.3).</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/image/mod.rs</path>
        <kind>module</kind>
        <symbol>mod.rs (image module public API)</symbol>
        <lines>1-65</lines>
        <reason>Public API surface for image module. Will add resize.rs exports here (pub use resize::*)</reason>
      </artifact>
      <artifact>
        <path>src/image/loader.rs</path>
        <kind>module</kind>
        <symbol>load_from_path, load_from_bytes, MAX_IMAGE_WIDTH, MAX_IMAGE_HEIGHT</symbol>
        <lines>10-16, 51-77, 99-127</lines>
        <reason>Story 3.1 image loading provides DynamicImage input for resize. MAX_IMAGE_WIDTH/HEIGHT (10,000) constraints apply to resize output validation</reason>
      </artifact>
      <artifact>
        <path>src/error.rs</path>
        <kind>module</kind>
        <symbol>DotmaxError::InvalidImageDimensions</symbol>
        <lines>128-130</lines>
        <reason>Existing error variant for invalid dimensions. Use for resize dimension validation (zero dimensions, extreme ratios)</reason>
      </artifact>
      <artifact>
        <path>src/grid.rs</path>
        <kind>module</kind>
        <symbol>BrailleGrid, dots_to_char</symbol>
        <lines>1-149</lines>
        <reason>Understanding braille cell coordinate system (2×4 dots per cell). Terminal dimensions in cells must convert to pixel dimensions: pixels_wide = cells_wide × 2, pixels_tall = cells_tall × 4</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <dependency name="image" version="0.25" feature="image" purpose="Core image types (DynamicImage, imageops::resize, FilterType::Lanczos3)" />
        <dependency name="imageproc" version="0.24" feature="image" purpose="Image processing algorithms (future stories)" />
        <dependency name="tracing" version="0.1" purpose="Structured logging (debug!, info! macros for resize operations)" />
        <dependency name="thiserror" version="2.0" purpose="Error handling (DotmaxError derives)" />
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    Zero panics guarantee - All functions return Result&lt;T, DotmaxError&gt;. Validate dimensions before operations.
    Feature gate isolation - All resize code behind #[cfg(feature = "image")].
    MAX_IMAGE_WIDTH/HEIGHT = 10,000 - Enforce on resize output dimensions to prevent OOM.
    Braille cell math - Terminal dimensions (cells) to pixel dimensions: width_px = cells_w × 2, height_px = cells_h × 4.
    Performance budget - Resize must complete in &lt;10ms for typical images (800×600 → 160×96).
    Error context - Include dimensions in all error messages for debugging.
    Module location - src/image/resize.rs (create new file, add to mod.rs exports).
    Testing requirement - &gt;80% line coverage, unit tests for math, integration tests for pipeline.
    Clippy compliance - Zero warnings with -D warnings flag.
    Rustfmt formatted - All code formatted before commit.
  </constraints>
  <interfaces>
    <interface>
      <name>resize_to_terminal</name>
      <kind>function signature</kind>
      <signature>pub fn resize_to_terminal(image: &amp;DynamicImage, term_width: u16, term_height: u16) -&gt; Result&lt;DynamicImage, DotmaxError&gt;</signature>
      <path>src/image/resize.rs (to be created)</path>
    </interface>
    <interface>
      <name>resize_to_dimensions</name>
      <kind>function signature</kind>
      <signature>pub fn resize_to_dimensions(image: &amp;DynamicImage, target_width: u32, target_height: u32, preserve_aspect: bool) -&gt; Result&lt;DynamicImage, DotmaxError&gt;</signature>
      <path>src/image/resize.rs (to be created)</path>
    </interface>
    <interface>
      <name>image::imageops::resize</name>
      <kind>external API</kind>
      <signature>pub fn resize(image: &amp;DynamicImage, nwidth: u32, nheight: u32, filter: FilterType) -&gt; DynamicImage</signature>
      <path>image crate (dependency)</path>
    </interface>
    <interface>
      <name>image::imageops::FilterType::Lanczos3</name>
      <kind>enum variant</kind>
      <signature>FilterType::Lanczos3 - High quality resize filter (slower, best quality)</signature>
      <path>image crate (dependency)</path>
    </interface>
    <interface>
      <name>DynamicImage (from Story 3.1)</name>
      <kind>type</kind>
      <signature>Image type from load_from_path() and load_from_bytes(). Has .width() and .height() methods.</signature>
      <path>image crate, returned by src/image/loader.rs</path>
    </interface>
  </interfaces>
  <tests>
    <standards>
      Testing framework: Rust built-in test framework with #[test] attributes.
      Feature gates: All image tests behind #[cfg(feature = "image")].
      Coverage target: Greater than 80% line coverage for resize module.
      Test structure: Unit tests in module (#[cfg(test)] mod tests), integration tests in tests/ directory.
      Test fixtures: Reuse existing test images from tests/fixtures/images/ (sample.png 10×10, test_photo.jpg).
      Error testing: All error paths tested (zero dims, extreme ratios, invalid inputs).
      Benchmark framework: criterion.rs for performance validation (benches/image_conversion.rs).
      Performance target validation: Verify resize completes in less than 10ms for typical images.
      CI testing: GitHub Actions runs tests on Windows, Linux, macOS with stable Rust and MSRV 1.70.
      Quality gates: cargo test, cargo clippy -D warnings, cargo fmt --check all must pass.
    </standards>
    <locations>
      Unit tests: src/image/resize.rs in #[cfg(test)] mod tests block
      Integration tests: tests/image_rendering_tests.rs (new file or extend existing)
      Benchmarks: benches/image_conversion.rs (extend with resize benchmarks)
      Test fixtures: tests/fixtures/images/ (reuse sample.png, test_photo.jpg, add new if needed)
    </locations>
    <ideas>
      AC1 (Terminal Resize): Test resize_to_terminal(80, 24) calculates 160×96 pixels correctly. Test aspect ratio preserved. Test Lanczos3 filter used.
      AC2 (Manual Resize): Test resize_to_dimensions with preserve_aspect=true (letterbox/pillarbox). Test preserve_aspect=false (exact dimensions). Test various target dimensions.
      AC3 (Edge Cases): Test zero dimensions return InvalidImageDimensions error. Test extreme ratios (10000×1, 1×10000) handled. Test upscale prevention (small image, large target).
      AC4 (Aspect Ratio Math): Test calculate_fit_dimensions helper with 16:9, 4:3, 1:1, 21:9 ratios. Test letterboxing (wide→tall). Test pillarboxing (tall→wide). Test rounding correctness.
      AC5 (Pipeline Integration): Integration test: load_from_path → resize_to_terminal → verify dimensions. Integration test: load_from_bytes → resize_to_dimensions → verify output.
      AC6 (Performance): Benchmark resize 800×600 → 160×96 (verify less than 10ms). Benchmark resize 1920×1080 → 400×100. Compare Lanczos3 vs Triangle vs Nearest filters.
      AC7 (Error Handling): Test terminal dimensions (0, 0) return error. Test target dimensions (0, height) return error. Test extreme resize ratios handled gracefully. Verify zero panics.
      AC8 (Test Coverage): Unit test all aspect ratios. Unit test edge cases. Integration test pipeline. Measure coverage with cargo tarpaulin, verify greater than 80%.
      AC9 (Documentation): Verify rustdoc examples compile (cargo test --doc). Verify examples/ programs compile and run. Check documentation completeness.
    </ideas>
  </tests>
</story-context>
