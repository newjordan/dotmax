<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>6</epicId>
    <storyId>2</storyId>
    <title>Implement Frame Timing and Rate Control</title>
    <status>drafted</status>
    <generatedAt>2025-11-24</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/6-2-implement-frame-timing-and-rate-control.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer creating animations at specific frame rates</asA>
    <iWant>precise timing control (30fps, 60fps, custom)</iWant>
    <soThat>animations play at consistent speed across systems</soThat>
    <tasks>
      <task id="1" ac="1">
        <title>Create FrameTimer Struct</title>
        <subtasks>
          <subtask id="1.1">Create `src/animation/timing.rs` file</subtask>
          <subtask id="1.2">Define `FrameTimer` struct with fields: `target_fps: u32`, `frame_duration: Duration`, `last_frame: Instant`, `frame_times: VecDeque&lt;Duration&gt;`</subtask>
          <subtask id="1.3">Implement `FrameTimer::new(target_fps: u32) -> Self`</subtask>
          <subtask id="1.4">Add FPS validation (1-240 range, return sensible defaults for invalid)</subtask>
          <subtask id="1.5">Calculate `frame_duration = Duration::from_secs_f64(1.0 / target_fps as f64)`</subtask>
          <subtask id="1.6">Add rustdoc with struct-level documentation</subtask>
        </subtasks>
      </task>
      <task id="2" ac="2,7">
        <title>Implement wait_for_next_frame()</title>
        <subtasks>
          <subtask id="2.1">Add `pub fn wait_for_next_frame(&amp;mut self)`</subtask>
          <subtask id="2.2">Calculate `elapsed = Instant::now().duration_since(self.last_frame)`</subtask>
          <subtask id="2.3">Calculate `sleep_duration = self.frame_duration.saturating_sub(elapsed)`</subtask>
          <subtask id="2.4">If `sleep_duration > Duration::ZERO`, call `std::thread::sleep(sleep_duration)`</subtask>
          <subtask id="2.5">Record frame time in `frame_times` VecDeque</subtask>
          <subtask id="2.6">Update `self.last_frame = Instant::now()`</subtask>
          <subtask id="2.7">Add tracing::debug! when frame drop occurs (elapsed > target)</subtask>
          <subtask id="2.8">Add rustdoc explaining sleep behavior</subtask>
        </subtasks>
      </task>
      <task id="3" ac="3">
        <title>Implement actual_fps()</title>
        <subtasks>
          <subtask id="3.1">Add `pub fn actual_fps(&amp;self) -> f32`</subtask>
          <subtask id="3.2">Return 0.0 if `frame_times` is empty</subtask>
          <subtask id="3.3">Calculate average duration from rolling window</subtask>
          <subtask id="3.4">Convert average duration to FPS: `1.0 / avg_duration.as_secs_f32()`</subtask>
          <subtask id="3.5">Add constant `FRAME_WINDOW_SIZE: usize = 60` for rolling window</subtask>
          <subtask id="3.6">Add rustdoc with example showing FPS monitoring</subtask>
        </subtasks>
      </task>
      <task id="4" ac="4">
        <title>Implement frame_time()</title>
        <subtasks>
          <subtask id="4.1">Add `pub fn frame_time(&amp;self) -> Duration`</subtask>
          <subtask id="4.2">Return most recent entry from `frame_times`, or `Duration::ZERO` if empty</subtask>
          <subtask id="4.3">Add rustdoc explaining return value semantics</subtask>
        </subtasks>
      </task>
      <task id="5" ac="1,9">
        <title>Implement Accessor Methods</title>
        <subtasks>
          <subtask id="5.1">Add `pub fn target_fps(&amp;self) -> u32`</subtask>
          <subtask id="5.2">Add `pub fn target_frame_time(&amp;self) -> Duration` (returns frame_duration)</subtask>
          <subtask id="5.3">Add `pub fn reset(&amp;mut self)` to reset timing state</subtask>
          <subtask id="5.4">Add rustdoc for all accessor methods</subtask>
        </subtasks>
      </task>
      <task id="6" ac="5,6">
        <title>Write Unit Tests</title>
        <subtasks>
          <subtask id="6.1">Create `#[cfg(test)] mod tests` in `timing.rs`</subtask>
          <subtask id="6.2">Test `new()` initializes with correct frame duration (60fps = 16.67ms)</subtask>
          <subtask id="6.3">Test `new()` with edge cases (1fps, 240fps)</subtask>
          <subtask id="6.4">Test `target_fps()` returns correct value</subtask>
          <subtask id="6.5">Test `actual_fps()` returns 0.0 when no frames recorded</subtask>
          <subtask id="6.6">Test timing accuracy: run 100 frames at 60fps, verify average within +/-2ms</subtask>
          <subtask id="6.7">Test frame drop detection (simulate slow frame)</subtask>
          <subtask id="6.8">Test `reset()` clears frame history</subtask>
          <subtask id="6.9">Minimum 8 unit tests covering all APIs</subtask>
        </subtasks>
      </task>
      <task id="7" ac="5">
        <title>Add Benchmark</title>
        <subtasks>
          <subtask id="7.1">Add `FrameTimer` benchmark to `benches/animation.rs`</subtask>
          <subtask id="7.2">Benchmark `wait_for_next_frame()` overhead (should be &lt;1ms)</subtask>
          <subtask id="7.3">Benchmark FPS calculation overhead</subtask>
          <subtask id="7.4">Document timing characteristics per platform</subtask>
        </subtasks>
      </task>
      <task id="8" ac="6">
        <title>Create Visual Example</title>
        <subtasks>
          <subtask id="8.1">Create `examples/fps_control.rs`</subtask>
          <subtask id="8.2">Initialize FrameBuffer and FrameTimer</subtask>
          <subtask id="8.3">Animation loop showing moving dot or incrementing counter</subtask>
          <subtask id="8.4">Display actual FPS on screen each frame</subtask>
          <subtask id="8.5">Add keyboard handling to toggle between 30fps/60fps (optional enhancement)</subtask>
          <subtask id="8.6">Add Ctrl+C handler for graceful exit</subtask>
          <subtask id="8.7">Add comments explaining timing workflow</subtask>
        </subtasks>
      </task>
      <task id="9" ac="9">
        <title>Update Module Exports</title>
        <subtasks>
          <subtask id="9.1">Add `pub mod timing;` to `src/animation/mod.rs`</subtask>
          <subtask id="9.2">Export `FrameTimer` from `src/animation/mod.rs`</subtask>
          <subtask id="9.3">Re-export from `src/lib.rs`: `pub use animation::FrameTimer;`</subtask>
          <subtask id="9.4">Verify public API is accessible from crate root</subtask>
        </subtasks>
      </task>
      <task id="10" ac="all">
        <title>Final Validation</title>
        <subtasks>
          <subtask id="10.1">Run full test suite: `cargo test --lib --all-features`</subtask>
          <subtask id="10.2">Run clippy: `cargo clippy --lib --example fps_control --bench animation -- -D warnings`</subtask>
          <subtask id="10.3">Run rustdoc: `RUSTDOCFLAGS="-D warnings" cargo doc --no-deps`</subtask>
          <subtask id="10.4">Run doc tests: `cargo test --doc`</subtask>
          <subtask id="10.5">Run benchmark: `cargo bench --bench animation`</subtask>
          <subtask id="10.6">Manual test: Run fps_control example and verify FPS display</subtask>
          <subtask id="10.7">Verify timing accuracy at 30fps and 60fps</subtask>
          <subtask id="10.8">All ACs verified with evidence</subtask>
        </subtasks>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">
      <title>FrameTimer::new(fps) Initializes with Target Frame Rate</title>
      <requirements>
        - `FrameTimer::new(target_fps: u32) -> Self` in `src/animation/timing.rs`
        - Initializes with target frame rate (e.g., 30, 60, 120)
        - Calculates `frame_duration` from target FPS (1000ms / fps)
        - Stores initial `Instant::now()` as timing reference
        - Validates FPS range: min 1, max 240 (per NFR security constraints)
      </requirements>
    </criterion>
    <criterion id="AC2">
      <title>wait_for_next_frame() Sleeps Appropriate Duration</title>
      <requirements>
        - `pub fn wait_for_next_frame(&amp;mut self)`
        - Calculates elapsed time since last frame
        - Sleeps for `(target_duration - elapsed)` if ahead of schedule
        - No sleep if behind schedule (graceful frame drop)
        - Updates `last_frame` timestamp after wait
        - Records frame time for FPS calculation
      </requirements>
    </criterion>
    <criterion id="AC3">
      <title>actual_fps() Returns Rolling Average of Real Frame Rate</title>
      <requirements>
        - `pub fn actual_fps(&amp;self) -> f32`
        - Maintains rolling window of recent frame times (e.g., last 60 frames)
        - Calculates average FPS from window
        - Returns 0.0 if no frames recorded yet
        - Uses `VecDeque&lt;Duration&gt;` for efficient window management
      </requirements>
    </criterion>
    <criterion id="AC4">
      <title>frame_time() Returns Duration of Last Frame</title>
      <requirements>
        - `pub fn frame_time(&amp;self) -> Duration`
        - Returns actual duration of most recent frame
        - Useful for debugging and performance monitoring
        - Returns `Duration::ZERO` if no frames completed
      </requirements>
    </criterion>
    <criterion id="AC5">
      <title>Timing Accuracy Within +/-2ms at 60fps</title>
      <requirements>
        - Target: 16.67ms per frame at 60fps
        - Acceptable variance: +/-2ms (14.67ms to 18.67ms)
        - Unit tests verify timing accuracy over 100+ frames
        - Document OS-specific timing behaviors (Linux ~1ms, Windows ~15ms default)
      </requirements>
    </criterion>
    <criterion id="AC6">
      <title>Example fps_control.rs Displays Real-Time FPS</title>
      <requirements>
        - Create `examples/fps_control.rs`
        - Demonstrates FrameTimer usage with FrameBuffer
        - Displays actual FPS in terminal (updated each frame)
        - Shows simple animation (e.g., counter or moving dot)
        - Allows toggling between 30fps and 60fps via keypress
        - Graceful Ctrl+C exit
      </requirements>
    </criterion>
    <criterion id="AC7">
      <title>Handles Frame Drops Gracefully</title>
      <requirements>
        - If frame computation exceeds target duration, skip sleep
        - No "catchup" accumulation (don't try to render extra frames)
        - `actual_fps()` accurately reflects dropped frames
        - Tracing debug log when frame drop occurs
      </requirements>
    </criterion>
    <criterion id="AC8">
      <title>Zero Clippy Warnings in timing.rs</title>
      <requirements>
        - `cargo clippy --lib -- -D warnings` passes with zero warnings for animation module
        - No `#[allow(...)]` attributes except where justified with comment
        - Follows Rust naming conventions (snake_case functions, PascalCase types)
      </requirements>
    </criterion>
    <criterion id="AC9">
      <title>Rustdoc with Examples for All Public Methods</title>
      <requirements>
        - All public functions have `///` doc comments
        - Each method includes at least one `# Examples` code block
        - Examples compile via `cargo test --doc`
        - Module-level documentation explains frame timing concepts
        - Zero rustdoc warnings: `RUSTDOCFLAGS="-D warnings" cargo doc`
      </requirements>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/architecture.md</path>
        <title>dotmax Architecture Document</title>
        <section>Pattern 3: Buffer Reuse for Animation</section>
        <snippet>FrameTimer works with FrameBuffer for animation loops. Target 60fps with &lt;10% single-core CPU (NFR-P2). Frame timing critical for consistent animation speed.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>dotmax Architecture Document</title>
        <section>Technology Stack - Module Structure</section>
        <snippet>src/animation.rs - Animation &amp; frames. FrameBuffer, Frame timing, loop management, Flicker-free rendering.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>dotmax Product Requirements Document</title>
        <section>FR39-43: Animation &amp; Frame Management</section>
        <snippet>FR39: Frame timing control for animation playback. FR40: Animation loops with specified frame rates. FR70: 60fps with &lt;10% CPU. NFR-P2: Sustained 60fps min, target 120fps.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/6-1-implement-frame-buffer-and-double-buffering.md</path>
        <title>Story 6.1 Reference (Previous Story)</title>
        <section>Dev Notes - Learnings</section>
        <snippet>FrameBuffer API complete: get_back_buffer(), swap_buffers() ~2.2ns (450,000x faster than 1ms target), render(). Module at src/animation/. Benchmark infrastructure in benches/animation.rs.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/animation/mod.rs</path>
        <kind>module</kind>
        <symbol>animation</symbol>
        <lines>1-54</lines>
        <reason>Animation module root - add `pub mod timing;` and export `FrameTimer` here</reason>
      </artifact>
      <artifact>
        <path>src/animation/frame_buffer.rs</path>
        <kind>struct</kind>
        <symbol>FrameBuffer</symbol>
        <lines>75-264</lines>
        <reason>Reference implementation for double-buffering pattern. FrameTimer integrates with FrameBuffer for complete animation workflow.</reason>
      </artifact>
      <artifact>
        <path>src/lib.rs</path>
        <kind>module</kind>
        <symbol>lib</symbol>
        <lines>91-92</lines>
        <reason>Add `pub use animation::FrameTimer;` re-export alongside existing `FrameBuffer` export</reason>
      </artifact>
      <artifact>
        <path>benches/animation.rs</path>
        <kind>benchmark</kind>
        <symbol>animation benchmarks</symbol>
        <lines>1-121</lines>
        <reason>Existing criterion benchmarks for animation. Add FrameTimer benchmarks to this file.</reason>
      </artifact>
      <artifact>
        <path>examples/animation_buffer.rs</path>
        <kind>example</kind>
        <symbol>animation_buffer</symbol>
        <lines>1-225</lines>
        <reason>Reference for animation example structure. fps_control.rs should follow similar pattern with FrameTimer integration.</reason>
      </artifact>
      <artifact>
        <path>src/grid.rs</path>
        <kind>struct</kind>
        <symbol>BrailleGrid</symbol>
        <reason>Core buffer structure used by FrameBuffer. FrameTimer works alongside for timing control.</reason>
      </artifact>
      <artifact>
        <path>src/render.rs</path>
        <kind>struct</kind>
        <symbol>TerminalRenderer</symbol>
        <reason>Terminal output renderer. Example will use this for display.</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <package name="ratatui" version="0.29">Terminal UI framework</package>
        <package name="crossterm" version="0.29">Cross-platform terminal I/O, keyboard events</package>
        <package name="thiserror" version="2.0">Error handling derive macros</package>
        <package name="tracing" version="0.1">Structured logging - use for frame drop debug logs</package>
        <package name="criterion" version="0.7" dev="true">Benchmarking framework</package>
        <package name="tracing-subscriber" version="0.3" dev="true">Log output for tests</package>
      </rust>
      <stdlib>
        <module name="std::time::{Duration, Instant}">High-precision timing primitives</module>
        <module name="std::thread::sleep">Frame pacing sleep function</module>
        <module name="std::collections::VecDeque">Rolling FPS window storage</module>
      </stdlib>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint source="architecture.md">Error handling uses `DotmaxError` enum with thiserror - but FrameTimer is infallible (no Result returns needed per tech spec)</constraint>
    <constraint source="architecture.md">All public functions have rustdoc with `# Examples` code blocks that compile via `cargo test --doc`</constraint>
    <constraint source="architecture.md">Use `tracing` crate for structured logging - debug! for frame drops</constraint>
    <constraint source="PRD.md - NFR-P2">Sustained 60fps minimum with &lt;10% single-core CPU usage</constraint>
    <constraint source="PRD.md - NFR-P4">CPU efficiency: &lt;10% single-core usage at 60fps active animation</constraint>
    <constraint source="story">FPS validation: min 1, max 240 (clamp invalid values to range)</constraint>
    <constraint source="story">Timing accuracy: +/-2ms at 60fps (16.67ms target)</constraint>
    <constraint source="story">No catch-up accumulation on frame drops - skip sleep, continue</constraint>
    <constraint source="architecture.md">Follow Rust naming conventions (snake_case functions, PascalCase types)</constraint>
    <constraint source="clippy.toml">Clippy lints: all=deny, pedantic=warn, nursery=warn</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>FrameTimer</name>
      <kind>struct (authoritative from tech-spec)</kind>
      <signature>
pub struct FrameTimer {
    target_fps: u32,
    frame_duration: Duration,
    last_frame: Instant,
    frame_times: VecDeque&lt;Duration&gt;,  // Rolling window for FPS calc
}

impl FrameTimer {
    pub fn new(target_fps: u32) -> Self;
    pub fn wait_for_next_frame(&amp;mut self);  // Blocks until next frame time
    pub fn actual_fps(&amp;self) -> f32;        // Rolling average FPS
    pub fn frame_time(&amp;self) -> Duration;   // Last frame duration
    pub fn target_fps(&amp;self) -> u32;
    pub fn target_frame_time(&amp;self) -> Duration;
    pub fn reset(&amp;mut self);                // Reset timing state
}
      </signature>
      <path>src/animation/timing.rs</path>
    </interface>
    <interface>
      <name>FrameBuffer</name>
      <kind>struct (from Story 6.1)</kind>
      <signature>
impl FrameBuffer {
    pub fn new(width: usize, height: usize) -> Self;
    pub fn get_back_buffer(&amp;mut self) -> &amp;mut BrailleGrid;
    pub fn get_front_buffer(&amp;self) -> &amp;BrailleGrid;
    pub fn swap_buffers(&amp;mut self);
    pub fn render(&amp;self, renderer: &amp;mut TerminalRenderer) -> Result&lt;(), DotmaxError&gt;;
    pub fn width(&amp;self) -> usize;
    pub fn height(&amp;self) -> usize;
}
      </signature>
      <path>src/animation/frame_buffer.rs</path>
    </interface>
    <interface>
      <name>TerminalRenderer</name>
      <kind>struct (from Epic 2)</kind>
      <signature>
impl TerminalRenderer {
    pub fn new() -> Result&lt;Self, DotmaxError&gt;;
    pub fn render(&amp;mut self, grid: &amp;BrailleGrid) -> Result&lt;(), DotmaxError&gt;;
    pub fn get_terminal_size(&amp;self) -> Result&lt;(u16, u16), DotmaxError&gt;;
    pub fn cleanup(&amp;mut self) -> Result&lt;(), DotmaxError&gt;;
}
      </signature>
      <path>src/render.rs</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing follows established patterns from Epic 2-6: unit tests in `#[cfg(test)] mod tests` within source files, criterion benchmarks in `benches/`, doc tests in rustdoc `# Examples` blocks, and visual examples in `examples/`. All tests must pass `cargo test --lib --all-features` and `cargo test --doc`. Clippy pedantic lints are enforced. Minimum 8 unit tests required per story AC. Current test count: 507+ library tests passing.
    </standards>
    <locations>
      <location>src/animation/timing.rs - Unit tests in `#[cfg(test)] mod tests`</location>
      <location>benches/animation.rs - criterion benchmarks for FrameTimer operations</location>
      <location>examples/fps_control.rs - Visual demonstration of FrameTimer</location>
      <location>Doc tests via `cargo test --doc`</location>
    </locations>
    <ideas>
      <idea ac="AC1">Test new() with 60fps calculates frame_duration = 16.67ms</idea>
      <idea ac="AC1">Test new() clamps invalid FPS (0 -> 1, 500 -> 240)</idea>
      <idea ac="AC1">Test new() edge cases: 1fps, 30fps, 60fps, 120fps, 240fps</idea>
      <idea ac="AC2">Test wait_for_next_frame() updates last_frame timestamp</idea>
      <idea ac="AC2">Test wait_for_next_frame() records frame time in VecDeque</idea>
      <idea ac="AC3">Test actual_fps() returns 0.0 when no frames recorded</idea>
      <idea ac="AC3">Test actual_fps() calculates correct average from rolling window</idea>
      <idea ac="AC3">Test actual_fps() window size is 60 frames max</idea>
      <idea ac="AC4">Test frame_time() returns Duration::ZERO initially</idea>
      <idea ac="AC4">Test frame_time() returns most recent frame duration after wait_for_next_frame()</idea>
      <idea ac="AC5">Integration test: Run 100 frames at 60fps, verify average frame time within 14.67-18.67ms</idea>
      <idea ac="AC7">Test frame drop: simulate slow frame (> target), verify no sleep occurs</idea>
      <idea ac="AC7">Test frame drop: verify actual_fps() reflects dropped frames accurately</idea>
      <idea ac="AC5">Test reset() clears frame_times and resets last_frame</idea>
      <idea ac="AC7">Benchmark: wait_for_next_frame() overhead should be negligible (&lt;1ms)</idea>
      <idea ac="AC7">Benchmark: actual_fps() calculation should be &lt;100us</idea>
    </ideas>
  </tests>
</story-context>
