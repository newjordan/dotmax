<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3.5</epicId>
    <storyId>3.5.2</storyId>
    <title>Fix Resize/Refresh Behavior</title>
    <status>drafted</status>
    <generatedAt>2025-11-21</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/3-5-2-fix-resize-refresh-behavior.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>user viewing images in the terminal</asA>
    <iWant>automatic re-rendering when the terminal window is resized</iWant>
    <soThat>the image scales appropriately without requiring manual intervention</soThat>
    <tasks>
- [ ] **Task 1: Research Current Event Handling in Examples** (AC: #6)
  - [ ] 1.1: Review `examples/simple_image.rs` event loop structure
  - [ ] 1.2: Review `examples/image_browser.rs` event loop structure
  - [ ] 1.3: Check if crossterm Event::Resize is already handled anywhere
  - [ ] 1.4: Identify which examples currently use event polling
  - [ ] 1.5: Document current state (baseline before changes)

- [ ] **Task 2: Implement Resize Event Detection** (AC: #1, #7)
  - [ ] 2.1: Add crossterm Event::Resize handling to example event loops
  - [ ] 2.2: Use `crossterm::event::poll()` or `read()` to capture events
  - [ ] 2.3: Log resize events via tracing for debugging (info level)
  - [ ] 2.4: Test on Linux to confirm events are captured
  - [ ] 2.5: Test on other platforms if available (macOS, Windows)

- [ ] **Task 3: Fetch New Terminal Dimensions** (AC: #2)
  - [ ] 3.1: After resize event, call `crossterm::terminal::size()?`
  - [ ] 3.2: Handle potential errors (no panics, return Result)
  - [ ] 3.3: Convert terminal (cols, rows) to braille grid dimensions (cols/2, rows/4)
  - [ ] 3.4: Log new dimensions for debugging

- [ ] **Task 4: Trigger Image Re-Render** (AC: #2, #3)
  - [ ] 4.1: Store original image path/buffer for re-rendering
  - [ ] 4.2: Re-instantiate ImageRenderer with new terminal dimensions
  - [ ] 4.3: Re-run full pipeline: load (or use cached) → resize → dither → threshold → map → render
  - [ ] 4.4: Verify aspect ratio preservation (use Story 3.2 resize logic)
  - [ ] 4.5: Clear terminal before re-render to avoid artifacts

- [ ] **Task 5: Implement Resize Debouncing (if needed)** (AC: #5)
  - [ ] 5.1: Test rapid resize events (drag terminal window continuously)
  - [ ] 5.2: If performance poor, add debouncing (e.g., 100ms delay after last resize)
  - [ ] 5.3: Use `std::time::Instant` to track last resize time
  - [ ] 5.4: Only re-render if >100ms since last resize event
  - [ ] 5.5: Document debouncing strategy in code comments

- [ ] **Task 6: Update simple_image.rs Example** (AC: #4, #6)
  - [ ] 6.1: Add event loop with resize handling after initial render
  - [ ] 6.2: Structure: loop { poll events → if Resize → re-render → if Quit → break }
  - [ ] 6.3: Keep example simple (<100 lines if possible)
  - [ ] 6.4: Add comments explaining resize pattern
  - [ ] 6.5: Test manually: run example, resize terminal, verify re-render

- [ ] **Task 7: Update image_browser.rs Example** (AC: #4, #6)
  - [ ] 7.1: Integrate resize handling into existing event loop
  - [ ] 7.2: Preserve interactive features (navigation, zoom, etc.)
  - [ ] 7.3: Ensure resize works while browsing multiple images
  - [ ] 7.4: Add comments explaining resize integration with other controls
  - [ ] 7.5: Test manually: run example, navigate images, resize terminal multiple times

- [ ] **Task 8: Edge Case Testing** (AC: #8)
  - [ ] 8.1: Test with very small terminal (10×10) - verify no panic, graceful degradation
  - [ ] 8.2: Test with very large terminal (300×100) - verify no memory spikes
  - [ ] 8.3: Test rapid resize (drag window continuously) - verify stability
  - [ ] 8.4: Simulate terminal size query failure (if possible) - verify error handling
  - [ ] 8.5: Document any edge cases that need graceful failure

- [ ] **Task 9: Performance Validation** (AC: #5)
  - [ ] 9.1: Measure re-render time for typical image (<1MB PNG)
  - [ ] 9.2: Verify <200ms target met
  - [ ] 9.3: Test with large image (4K PNG) - document performance if slower
  - [ ] 9.4: Use RUST_LOG=debug to measure pipeline stages
  - [ ] 9.5: If performance poor, profile and optimize bottleneck

- [ ] **Task 10: Cross-Platform Testing** (AC: #7)
  - [ ] 10.1: Run examples on Linux and verify resize works
  - [ ] 10.2: Run examples on macOS (if available) and verify resize works
  - [ ] 10.3: Run examples on Windows (if available) and verify resize works
  - [ ] 10.4: Document any platform-specific quirks discovered
  - [ ] 10.5: Confirm no #[cfg(target_os = "...")] hacks needed

- [ ] **Task 11: Documentation Updates** (AC: #9)
  - [ ] 11.1: Add "Automatic Resize" section to README.md or docs/
  - [ ] 11.2: Update example README.md with resize behavior notes
  - [ ] 11.3: Add inline comments to examples explaining resize pattern
  - [ ] 11.4: Document any known limitations (e.g., extreme terminal sizes)
  - [ ] 11.5: Provide code snippet template for resize handling

- [ ] **Task 12: Final Integration & Testing** (AC: #1-9)
  - [ ] 12.1: Run `cargo build --examples --all-features` - verify compilation
  - [ ] 12.2: Run `cargo clippy --examples --all-features` - verify zero warnings
  - [ ] 12.3: Run all updated examples manually and test resize on each
  - [ ] 12.4: Verify behavior matches all 9 acceptance criteria
  - [ ] 12.5: Create demo recording or screenshot sequence (optional, for documentation)
    </tasks>
  </story>

  <acceptanceCriteria>
1. **AC1: Terminal Resize Event Detection**
   - Application detects when terminal dimensions change
   - Uses crossterm's `Event::Resize(width, height)` or equivalent
   - Event polling/listening integrated into example applications
   - Terminal dimension changes captured reliably across platforms (Linux, macOS, Windows)

2. **AC2: Automatic Re-Render on Resize**
   - When resize event detected, trigger complete re-render of current image
   - Fetch new terminal dimensions via `crossterm::terminal::size()`
   - Recalculate target dimensions for braille grid (width/2, height/4)
   - Re-run image pipeline: resize → dither → threshold → map → render

3. **AC3: Aspect Ratio Preservation Maintained**
   - Resized output maintains original aspect ratio (Story 3.2 behavior)
   - ImageRenderer respects original resize/fit logic
   - No distortion or stretching regardless of new terminal size
   - Fits within new terminal bounds (both width and height constraints)

4. **AC4: No Manual Refresh Required**
   - User does not need to restart application
   - User does not need to press refresh key
   - Resize is automatic and seamless
   - Application continues running after resize with updated display

5. **AC5: Performance Acceptable During Resize**
   - Re-render completes within 200ms for typical images (<1MB)
   - No flickering or visual artifacts during resize
   - Resize event debouncing if needed (avoid re-rendering on every pixel change)
   - Application remains responsive during resize operation

6. **AC6: Example Applications Updated**
   - At least 2 image examples demonstrate resize behavior:
     - `simple_image.rs` or equivalent basic example
     - `image_browser.rs` or equivalent interactive example
   - Event loop structured to handle resize events
   - Clear code comments showing resize pattern for future examples

7. **AC7: Cross-Platform Compatibility**
   - Resize works on Linux (tested)
   - Resize works on macOS (if available for testing)
   - Resize works on Windows (if available for testing)
   - No platform-specific hacks or workarounds

8. **AC8: Edge Cases Handled**
   - Very small terminal (<10×10 chars) handled gracefully (don't panic)
   - Very large terminal (>300×100 chars) handled without memory spikes
   - Rapid resize events (user dragging window) don't crash application
   - Terminal size query failures return appropriate errors (no panics)

9. **AC9: Documentation Updated**
   - Example code includes comments explaining resize handling
   - README or docs note automatic resize capability
   - Known limitations documented (if any)
   - Developers understand pattern for implementing resize in their apps
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <artifact>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Terminal Abstraction</section>
        <snippet>TerminalBackend trait abstracts terminal operations. DefaultTerminal uses ratatui + crossterm. Provides resize event handling capabilities via crossterm Event::Resize.</snippet>
      </artifact>
      <artifact>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Technology Stack Details</section>
        <snippet>crossterm = "0.29" provides cross-platform terminal I/O including event handling (keyboard, mouse, resize, focus). Works on Windows, Linux, macOS without modification.</snippet>
      </artifact>
      <artifact>
        <path>docs/sprint-artifacts/epic-3-retro-2025-11-21.md</path>
        <title>Epic 3 Retrospective</title>
        <section>Minor Issues Discovered</section>
        <snippet>Resize doesn't refresh on terminal window size change. User resizes terminal window, image remains at original size. Priority: HIGH. Estimated effort: 1-2 days.</snippet>
      </artifact>
    </docs>
    <code>
      <artifact>
        <path>examples/simple_image.rs</path>
        <kind>example</kind>
        <symbol>main</symbol>
        <lines>1-27</lines>
        <reason>Current one-shot render example that needs resize event loop added</reason>
      </artifact>
      <artifact>
        <path>examples/image_browser.rs</path>
        <kind>example</kind>
        <symbol>ImageBrowser</symbol>
        <lines>1-150</lines>
        <reason>Interactive example with existing event loop structure - needs resize event integration</reason>
      </artifact>
      <artifact>
        <path>src/render.rs</path>
        <kind>module</kind>
        <symbol>TerminalRenderer</symbol>
        <lines>1-200</lines>
        <reason>Terminal backend implementation using ratatui + crossterm, provides rendering capabilities</reason>
      </artifact>
      <artifact>
        <path>src/image/mod.rs</path>
        <kind>module</kind>
        <symbol>ImageRenderer</symbol>
        <lines>1-200</lines>
        <reason>High-level image rendering API with builder pattern, handles full pipeline including resize</reason>
      </artifact>
      <artifact>
        <path>src/image/resize.rs</path>
        <kind>module</kind>
        <symbol>resize_to_terminal</symbol>
        <lines>N/A</lines>
        <reason>Terminal dimension detection and aspect ratio preservation logic (Story 3.2)</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <dependency name="crossterm" version="0.29">Cross-platform terminal I/O with event handling (Event::Resize, poll, read)</dependency>
        <dependency name="ratatui" version="0.29">Terminal UI framework, abstracted via TerminalBackend trait</dependency>
        <dependency name="image" version="0.25" optional="true">Image loading and processing (feature-gated)</dependency>
        <dependency name="imageproc" version="0.24" optional="true">Image processing algorithms (feature-gated)</dependency>
        <dependency name="tracing" version="0.1">Structured logging for debug output</dependency>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
- **Zero Panics**: All operations must return `Result<T, DotmaxError>`. Terminal size queries, event reading, and rendering must handle errors gracefully.
- **Clippy Clean**: All examples held to same standard as src/ code (per Story 3.5.1). Must pass `cargo clippy --examples -- -D warnings`.
- **Cross-Platform**: Must work identically on Windows, Linux, macOS without platform-specific #[cfg] hacks.
- **Aspect Ratio Preservation**: Must maintain Story 3.2 behavior - no distortion regardless of terminal size.
- **Performance Target**: Re-render within 200ms for typical images (<1MB). If debouncing added, 100ms delay max.
- **No Library Changes**: This is primarily an examples/documentation story. Core library (src/) already supports necessary operations.
- **Event Loop Pattern**: Use crossterm::event::poll() with timeout, handle Event::Resize, clean event-driven architecture.
- **Code Quality**: Examples demonstrate best practices (proper error handling, no unwrap, well-commented).
  </constraints>

  <interfaces>
    <interface>
      <name>crossterm::event::Event</name>
      <kind>enum</kind>
      <signature>
pub enum Event {
    Key(KeyEvent),
    Mouse(MouseEvent),
    Resize(u16, u16),  // width, height in characters
    FocusGained,
    FocusLost,
    Paste(String),
}
      </signature>
      <path>crossterm crate</path>
    </interface>
    <interface>
      <name>crossterm::event::poll</name>
      <kind>function</kind>
      <signature>
pub fn poll(timeout: Duration) -> io::Result&lt;bool&gt;
// Returns true if an event is available, false if timeout elapsed
      </signature>
      <path>crossterm crate</path>
    </interface>
    <interface>
      <name>crossterm::event::read</name>
      <kind>function</kind>
      <signature>
pub fn read() -> io::Result&lt;Event&gt;
// Blocks until an event is available, returns the event
      </signature>
      <path>crossterm crate</path>
    </interface>
    <interface>
      <name>crossterm::terminal::size</name>
      <kind>function</kind>
      <signature>
pub fn size() -> io::Result&lt;(u16, u16)&gt;
// Returns (columns, rows) of terminal viewport
      </signature>
      <path>crossterm crate</path>
    </interface>
    <interface>
      <name>ImageRenderer</name>
      <kind>struct</kind>
      <signature>
impl ImageRenderer {
    pub fn new() -> Self;
    pub fn load_from_path(self, path: &Path) -> Result&lt;Self, DotmaxError&gt;;
    pub fn resize_to_terminal(self) -> Result&lt;Self, DotmaxError&gt;;
    pub fn resize(self, width: usize, height: usize, preserve_aspect: bool) -> Result&lt;Self, DotmaxError&gt;;
    pub fn render(self) -> Result&lt;BrailleGrid, DotmaxError&gt;;
}
      </signature>
      <path>src/image/mod.rs</path>
    </interface>
    <interface>
      <name>TerminalRenderer</name>
      <kind>struct</kind>
      <signature>
impl TerminalRenderer {
    pub fn new() -> Result&lt;Self, DotmaxError&gt;;
    pub fn render(&mut self, grid: &BrailleGrid) -> Result&lt;(), DotmaxError&gt;;
    pub fn cleanup(&mut self) -> Result&lt;(), DotmaxError&gt;;
}
      </signature>
      <path>src/render.rs</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
This is an examples/documentation story with manual testing focus. No unit tests required in src/.
Examples must compile cleanly with clippy (enforced by CI per Story 3.5.1).
Testing approach: Manual visual testing on Linux (primary), macOS/Windows if available.
Verify behavior through actual terminal resize actions and visual inspection.
    </standards>
    <locations>
- examples/*.rs - Updated examples with resize handling
- No new test files required (manual testing only)
    </locations>
    <ideas>
**Manual Test Cases (mapped to ACs):**

1. **AC1 - Event Detection**: Run simple_image.rs, resize terminal → verify event logged (RUST_LOG=info)
2. **AC2 - Auto Re-Render**: Resize terminal → verify image redraws automatically without manual intervention
3. **AC3 - Aspect Ratio**: Load landscape image, resize terminal to portrait → verify no distortion, aspect preserved
4. **AC4 - No Manual Refresh**: Resize multiple times → verify no restart/key press needed
5. **AC5 - Performance**: Time re-render with debug logging → verify <200ms for typical images
6. **AC6 - Examples Updated**: Verify both simple_image.rs and image_browser.rs have resize handling
7. **AC7 - Cross-Platform**: Test on Linux (minimum), macOS/Windows if available
8. **AC8 - Edge Cases**:
   - Make terminal 10×10 → verify graceful degradation, no panic
   - Make terminal 300×100 → verify no memory spike
   - Drag window continuously → verify no crash
9. **AC9 - Documentation**: Review code comments and README updates

**Debouncing Test**: Drag window rapidly → if flickering occurs, add debouncing and retest
    </ideas>
  </tests>
</story-context>
