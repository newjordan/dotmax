<story-context id="6-4-implement-frame-pre-rendering-and-caching" v="1.0">
  <metadata>
    <epicId>6</epicId>
    <storyId>4</storyId>
    <title>Implement Frame Pre-Rendering and Caching</title>
    <status>drafted</status>
    <generatedAt>2025-11-24</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/6-4-implement-frame-pre-rendering-and-caching.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer optimizing animation playback</asA>
    <iWant>to pre-render frames for known animations</iWant>
    <soThat>playback is smooth even for complex computations</soThat>
    <tasks>
      <task id="1" goal="Create PrerenderedAnimation Module Structure" acs="1,9">
        <subtask>1.1: Create src/animation/prerender.rs</subtask>
        <subtask>1.2: Add pub mod prerender; to src/animation/mod.rs</subtask>
        <subtask>1.3: Add module-level rustdoc explaining pre-rendering concept</subtask>
        <subtask>1.4: Import dependencies: BrailleGrid, FrameTimer, TerminalRenderer, DotmaxError</subtask>
        <subtask>1.5: Import file I/O: std::fs::File, std::io, std::path::Path</subtask>
      </task>
      <task id="2" goal="Define PrerenderedAnimation Struct" acs="1,5">
        <subtask>2.1: Define struct with frames: Vec&lt;BrailleGrid&gt;, frame_rate: u32</subtask>
        <subtask>2.2: Implement new(frame_rate: u32) with FPS clamping (1-240)</subtask>
        <subtask>2.3: Implement frame_count(&amp;self) -&gt; usize</subtask>
        <subtask>2.4: Implement frame_rate(&amp;self) -&gt; u32 accessor</subtask>
        <subtask>2.5: Add rustdoc with examples for constructor</subtask>
      </task>
      <task id="3" goal="Implement add_frame() Method" acs="2">
        <subtask>3.1: Implement add_frame(&amp;mut self, frame: BrailleGrid) -&gt; &amp;mut Self</subtask>
        <subtask>3.2: Push frame to internal Vec</subtask>
        <subtask>3.3: Return &amp;mut self for chaining</subtask>
        <subtask>3.4: Add rustdoc explaining frame storage semantics</subtask>
      </task>
      <task id="4" goal="Implement play() Method" acs="3">
        <subtask>4.1: Implement play(&amp;self, renderer: &amp;mut TerminalRenderer) -&gt; Result&lt;(), DotmaxError&gt;</subtask>
        <subtask>4.2: Return early if self.frames.is_empty()</subtask>
        <subtask>4.3: Create FrameTimer::new(self.frame_rate)</subtask>
        <subtask>4.4: Loop through frames, render each, call wait_for_next_frame()</subtask>
        <subtask>4.5: Add rustdoc with usage example</subtask>
      </task>
      <task id="5" goal="Implement play_loop() Method" acs="4">
        <subtask>5.1: Implement play_loop(&amp;self, renderer: &amp;mut TerminalRenderer) -&gt; Result&lt;(), DotmaxError&gt;</subtask>
        <subtask>5.2: Return early if self.frames.is_empty()</subtask>
        <subtask>5.3: Create FrameTimer::new(self.frame_rate)</subtask>
        <subtask>5.4: Outer loop: repeat indefinitely</subtask>
        <subtask>5.5: Check for Ctrl+C using crossterm::event::poll(Duration::ZERO)</subtask>
        <subtask>5.6: Detect KeyCode::Char('c') with KeyModifiers::CONTROL</subtask>
        <subtask>5.7: Break and return Ok(()) on Ctrl+C</subtask>
        <subtask>5.8: Add rustdoc explaining Ctrl+C behavior</subtask>
      </task>
      <task id="6" goal="Define File Format" acs="6,7">
        <subtask>6.1: Define binary format header: magic bytes b"DMAX" (4 bytes)</subtask>
        <subtask>6.2: Header: version (1 byte), frame_rate (u32 LE), frame_count (u32 LE), width (u32 LE), height (u32 LE)</subtask>
        <subtask>6.3: Frame data: sequential raw bytes from each BrailleGrid's dots vector</subtask>
        <subtask>6.4: Document format in module rustdoc</subtask>
      </task>
      <task id="7" goal="Implement save_to_file()" acs="6">
        <subtask>7.1: Implement save_to_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), DotmaxError&gt;</subtask>
        <subtask>7.2: Create parent directories if needed using std::fs::create_dir_all</subtask>
        <subtask>7.3: Write header with magic bytes and metadata</subtask>
        <subtask>7.4: Write each frame's dots data sequentially</subtask>
        <subtask>7.5: Use BufWriter for performance</subtask>
        <subtask>7.6: Map I/O errors to DotmaxError</subtask>
        <subtask>7.7: Add rustdoc with file format documentation</subtask>
      </task>
      <task id="8" goal="Implement load_from_file()" acs="7">
        <subtask>8.1: Implement load_from_file(path: &amp;Path) -&gt; Result&lt;Self, DotmaxError&gt;</subtask>
        <subtask>8.2: Read and validate magic bytes</subtask>
        <subtask>8.3: Read header fields (version, frame_rate, frame_count, dimensions)</subtask>
        <subtask>8.4: Reconstruct BrailleGrid for each frame</subtask>
        <subtask>8.5: Use BufReader for performance</subtask>
        <subtask>8.6: Return appropriate errors: FileNotFound, InvalidFormat, CorruptedData</subtask>
        <subtask>8.7: Add rustdoc with error cases documentation</subtask>
      </task>
      <task id="9" goal="Write Unit Tests" acs="1,2,3,5,6,7">
        <subtask>9.1: Create #[cfg(test)] mod tests in prerender.rs</subtask>
        <subtask>9.2: Test new() creates empty animation with correct frame rate</subtask>
        <subtask>9.3: Test FPS clamping (0 -&gt; 1, 1000 -&gt; 240)</subtask>
        <subtask>9.4: Test add_frame() increments frame count</subtask>
        <subtask>9.5: Test add_frame() chaining works</subtask>
        <subtask>9.6: Test frame_count() returns correct value</subtask>
        <subtask>9.7: Test save/load roundtrip preserves data</subtask>
        <subtask>9.8: Test load with invalid magic bytes returns error</subtask>
        <subtask>9.9: Test load with non-existent file returns error</subtask>
        <subtask>9.10: Minimum 8 unit tests</subtask>
      </task>
      <task id="10" goal="Create Visual Example" acs="8">
        <subtask>10.1: Create examples/prerendered_demo.rs</subtask>
        <subtask>10.2: Pre-render 60 frames of spinning animation</subtask>
        <subtask>10.3: Show timing of pre-render phase</subtask>
        <subtask>10.4: Demonstrate play() for single playback</subtask>
        <subtask>10.5: Demonstrate play_loop() with Ctrl+C exit message</subtask>
        <subtask>10.6: Add comments explaining the pre-rendering advantage</subtask>
        <subtask>10.7: Verify compiles: cargo build --example prerendered_demo</subtask>
      </task>
      <task id="11" goal="Update Module Exports" acs="9">
        <subtask>11.1: Export PrerenderedAnimation from src/animation/mod.rs</subtask>
        <subtask>11.2: Re-export from src/lib.rs: pub use animation::PrerenderedAnimation;</subtask>
        <subtask>11.3: Verify public API is accessible from crate root</subtask>
      </task>
      <task id="12" goal="Final Validation" acs="all">
        <subtask>12.1: Run full test suite: cargo test --lib --all-features</subtask>
        <subtask>12.2: Run clippy: cargo clippy --lib --example prerendered_demo -- -D warnings</subtask>
        <subtask>12.3: Run rustdoc: RUSTDOCFLAGS="-D warnings" cargo doc --no-deps</subtask>
        <subtask>12.4: Run doc tests: cargo test --doc</subtask>
        <subtask>12.5: Manual test: Run prerendered_demo example</subtask>
        <subtask>12.6: Test Ctrl+C in play_loop() exits gracefully</subtask>
        <subtask>12.7: Test save/load with actual file on disk</subtask>
        <subtask>12.8: All ACs verified with evidence</subtask>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">PrerenderedAnimation::new(frame_rate: u32) creates empty animation with specified playback rate, frame rate clamped to 1-240, constructor is infallible</criterion>
    <criterion id="AC2">add_frame(frame: BrailleGrid) stores frame in sequence, frames stored by value, no validation on dimensions, returns &amp;mut Self for builder-style chaining</criterion>
    <criterion id="AC3">play(&amp;self, renderer: &amp;mut TerminalRenderer) -&gt; Result&lt;(), DotmaxError&gt; renders frames at specified rate using FrameTimer internally, plays all frames once and returns Ok(()), returns immediately if no frames</criterion>
    <criterion id="AC4">play_loop(&amp;self, renderer: &amp;mut TerminalRenderer) -&gt; Result&lt;(), DotmaxError&gt; repeats indefinitely, stops gracefully on Ctrl+C (returns Ok(())), uses crossterm event polling, loops seamlessly</criterion>
    <criterion id="AC5">frame_count(&amp;self) -&gt; usize returns number of stored frames, returns 0 for empty animation</criterion>
    <criterion id="AC6">save_to_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), DotmaxError&gt; serializes animation to disk with binary format (header + frames), no compression in MVP, creates parent directories</criterion>
    <criterion id="AC7">load_from_file(path: &amp;Path) -&gt; Result&lt;Self, DotmaxError&gt; loads animation from disk, validates file format, handles file not found, permission denied, corrupt data</criterion>
    <criterion id="AC8">Example examples/prerendered_demo.rs demonstrates play() and play_loop() with 60+ frames spinning animation, shows zero computation during playback</criterion>
    <criterion id="AC9">cargo clippy --lib -- -D warnings passes with zero warnings for animation module, no #[allow(...)] except where justified, follows Rust naming conventions</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-6.md</path>
        <title>Epic 6 Technical Specification: Animation &amp; Frame Management</title>
        <section>Story 6.4: Frame Pre-Rendering and Caching</section>
        <snippet>PrerenderedAnimation API specification with new(), add_frame(), play(), play_loop(), frame_count(), save_to_file(), load_from_file(). All acceptance criteria AC6.4.1-AC6.4.9 defined.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>dotmax Architecture Document</title>
        <section>Pattern 3: Buffer Reuse for Animation</section>
        <snippet>Animation patterns for 60fps without allocating new grids each frame. Target &lt;500KB memory overhead per frame. Memory characteristics: 80x24 grid ~2KB per frame, 300 frames ~600KB.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>dotmax Epics and Stories</title>
        <section>Story 6.4: Implement Frame Pre-Rendering and Caching</section>
        <snippet>BDD acceptance criteria for PrerenderedAnimation struct with frame storage, playback, serialization. Prerequisites: Story 6.1-6.3 (animation infrastructure).</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/6-1-implement-frame-buffer-and-double-buffering.md</path>
        <title>Story 6.1: Frame Buffer and Double Buffering</title>
        <section>Dev Agent Record</section>
        <snippet>Reference for FrameBuffer pattern (similar struct design), BrailleGrid operations, swap_buffers benchmark (~2.4ns). Status: done.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/6-2-implement-frame-timing-and-rate-control.md</path>
        <title>Story 6.2: Frame Timing and Rate Control</title>
        <section>Dev Agent Record</section>
        <snippet>FrameTimer API: new(target_fps), wait_for_next_frame(), actual_fps(). FPS clamping pattern (1-240 range). Infallible constructor. Status: done.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/6-3-implement-animation-loop-helper.md</path>
        <title>Story 6.3: Animation Loop Helper</title>
        <section>Dev Notes</section>
        <snippet>Ctrl+C detection pattern using crossterm events, terminal cleanup patterns, builder-style method chaining. Status: review.</snippet>
      </doc>
    </docs>
    <code>
      <file>
        <path>src/animation/mod.rs</path>
        <kind>module</kind>
        <symbol>animation</symbol>
        <lines>1-58</lines>
        <reason>Module root for animation, re-exports FrameBuffer, FrameTimer, AnimationLoop. Add pub mod prerender here.</reason>
      </file>
      <file>
        <path>src/animation/frame_buffer.rs</path>
        <kind>component</kind>
        <symbol>FrameBuffer</symbol>
        <lines>75-264</lines>
        <reason>Reference for struct design pattern, BrailleGrid usage, swap_buffers(), render() method signature.</reason>
      </file>
      <file>
        <path>src/animation/timing.rs</path>
        <kind>component</kind>
        <symbol>FrameTimer</symbol>
        <lines>119-402</lines>
        <reason>REQUIRED: FrameTimer::new(fps), wait_for_next_frame() for playback timing. FPS clamping constants MIN_FPS=1, MAX_FPS=240.</reason>
      </file>
      <file>
        <path>src/animation/loop_helper.rs</path>
        <kind>component</kind>
        <symbol>AnimationLoop</symbol>
        <lines>389-406</lines>
        <reason>Reference for Ctrl+C detection pattern using crossterm::event::poll(Duration::ZERO) and event::read().</reason>
      </file>
      <file>
        <path>src/grid.rs</path>
        <kind>core</kind>
        <symbol>BrailleGrid</symbol>
        <lines>161-290</lines>
        <reason>Core frame storage type. Need access to patterns: Vec&lt;u8&gt; for serialization. dimensions(), width(), height(), new().</reason>
      </file>
      <file>
        <path>src/error.rs</path>
        <kind>core</kind>
        <symbol>DotmaxError</symbol>
        <lines>44-232</lines>
        <reason>Error type for play()/play_loop()/save_to_file()/load_from_file(). Terminal variant for I/O errors.</reason>
      </file>
      <file>
        <path>src/render.rs</path>
        <kind>core</kind>
        <symbol>TerminalRenderer</symbol>
        <lines>all</lines>
        <reason>Required for play() and play_loop() - renders BrailleGrid to terminal.</reason>
      </file>
      <file>
        <path>src/lib.rs</path>
        <kind>root</kind>
        <symbol>lib</symbol>
        <lines>91-92</lines>
        <reason>Add PrerenderedAnimation to pub use animation:: re-exports.</reason>
      </file>
      <file>
        <path>examples/animation_buffer.rs</path>
        <kind>example</kind>
        <symbol>animation_buffer</symbol>
        <lines>all</lines>
        <reason>Reference for animation example structure, terminal setup pattern.</reason>
      </file>
      <file>
        <path>examples/simple_animation.rs</path>
        <kind>example</kind>
        <symbol>simple_animation</symbol>
        <lines>all</lines>
        <reason>Reference for AnimationLoop usage pattern, Ctrl+C handling in examples.</reason>
      </file>
    </code>
    <dependencies>
      <rust>
        <core>
          <dep name="ratatui" version="0.29">Terminal UI framework</dep>
          <dep name="crossterm" version="0.29">Cross-platform terminal I/O, event polling for Ctrl+C</dep>
          <dep name="thiserror" version="2.0">Error handling derive macros</dep>
          <dep name="tracing" version="0.1">Structured logging</dep>
        </core>
        <stdlib>
          <dep name="std::fs">File, create_dir_all</dep>
          <dep name="std::io">Read, Write, BufReader, BufWriter</dep>
          <dep name="std::path">Path</dep>
          <dep name="std::time">Duration for event polling</dep>
        </stdlib>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint source="architecture.md">No unsafe code - rely on Rust's memory safety</constraint>
    <constraint source="architecture.md">All public functions return Result&lt;T, DotmaxError&gt; for fallible operations</constraint>
    <constraint source="architecture.md">Use tracing crate for logging (debug! for frame timing info)</constraint>
    <constraint source="tech-spec-epic-6.md">FPS validation: min 1, max 240 (clamp, don't error)</constraint>
    <constraint source="tech-spec-epic-6.md">Constructor is infallible (FPS clamping, not error)</constraint>
    <constraint source="tech-spec-epic-6.md">No compression in MVP for file storage - simple binary format</constraint>
    <constraint source="tech-spec-epic-6.md">Frame dropping when behind schedule (no catchup accumulation)</constraint>
    <constraint source="tech-spec-epic-6.md">Graceful Ctrl+C handling - return Ok(()), not error</constraint>
    <constraint source="epics.md">Memory: 80x24 grid ~2KB per frame, 300 frames ~600KB reasonable</constraint>
    <constraint source="architecture.md">Builder pattern return &amp;mut Self for chaining</constraint>
    <constraint source="architecture.md">Rustdoc with examples for all public methods</constraint>
    <constraint source="story">Binary format header: magic b"DMAX", version, frame_rate, frame_count, width, height</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>PrerenderedAnimation::new</name>
      <kind>constructor</kind>
      <signature>pub fn new(frame_rate: u32) -&gt; Self</signature>
      <path>src/animation/prerender.rs</path>
    </interface>
    <interface>
      <name>PrerenderedAnimation::add_frame</name>
      <kind>builder method</kind>
      <signature>pub fn add_frame(&amp;mut self, frame: BrailleGrid) -&gt; &amp;mut Self</signature>
      <path>src/animation/prerender.rs</path>
    </interface>
    <interface>
      <name>PrerenderedAnimation::play</name>
      <kind>method</kind>
      <signature>pub fn play(&amp;self, renderer: &amp;mut TerminalRenderer) -&gt; Result&lt;(), DotmaxError&gt;</signature>
      <path>src/animation/prerender.rs</path>
    </interface>
    <interface>
      <name>PrerenderedAnimation::play_loop</name>
      <kind>method</kind>
      <signature>pub fn play_loop(&amp;self, renderer: &amp;mut TerminalRenderer) -&gt; Result&lt;(), DotmaxError&gt;</signature>
      <path>src/animation/prerender.rs</path>
    </interface>
    <interface>
      <name>PrerenderedAnimation::frame_count</name>
      <kind>accessor</kind>
      <signature>pub fn frame_count(&amp;self) -&gt; usize</signature>
      <path>src/animation/prerender.rs</path>
    </interface>
    <interface>
      <name>PrerenderedAnimation::save_to_file</name>
      <kind>serialization</kind>
      <signature>pub fn save_to_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), DotmaxError&gt;</signature>
      <path>src/animation/prerender.rs</path>
    </interface>
    <interface>
      <name>PrerenderedAnimation::load_from_file</name>
      <kind>deserialization</kind>
      <signature>pub fn load_from_file(path: &amp;Path) -&gt; Result&lt;Self, DotmaxError&gt;</signature>
      <path>src/animation/prerender.rs</path>
    </interface>
    <interface>
      <name>FrameTimer::new</name>
      <kind>constructor (reuse)</kind>
      <signature>pub fn new(target_fps: u32) -&gt; Self</signature>
      <path>src/animation/timing.rs</path>
    </interface>
    <interface>
      <name>FrameTimer::wait_for_next_frame</name>
      <kind>method (reuse)</kind>
      <signature>pub fn wait_for_next_frame(&amp;mut self)</signature>
      <path>src/animation/timing.rs</path>
    </interface>
    <interface>
      <name>TerminalRenderer::render</name>
      <kind>method (reuse)</kind>
      <signature>pub fn render(&amp;mut self, grid: &amp;BrailleGrid) -&gt; Result&lt;(), DotmaxError&gt;</signature>
      <path>src/render.rs</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing follows Rust conventions with #[cfg(test)] mod tests in source files. Unit tests cover individual functions, integration tests in tests/ directory. All public API methods require tests verifying both success and error paths. Use assert! and assert_eq! with descriptive messages. AC-tagged tests for traceability. Minimum 8 unit tests for this story per AC requirements.
    </standards>
    <locations>
      <location>src/animation/prerender.rs (unit tests in #[cfg(test)] mod tests)</location>
      <location>tests/animation_tests.rs (if integration tests needed)</location>
      <location>examples/prerendered_demo.rs (visual validation)</location>
    </locations>
    <ideas>
      <idea ac="AC1">Test new() creates empty animation with correct frame rate</idea>
      <idea ac="AC1">Test FPS clamping: new(0) -&gt; 1, new(1000) -&gt; 240</idea>
      <idea ac="AC1">Test new() is infallible (no Result return)</idea>
      <idea ac="AC2">Test add_frame() increments frame_count()</idea>
      <idea ac="AC2">Test add_frame() chaining: anim.add_frame(g1).add_frame(g2)</idea>
      <idea ac="AC2">Test add_frame() accepts different sized grids</idea>
      <idea ac="AC3">Test play() with empty animation returns Ok(()) immediately</idea>
      <idea ac="AC5">Test frame_count() returns 0 for empty animation</idea>
      <idea ac="AC5">Test frame_count() returns correct count after multiple add_frame()</idea>
      <idea ac="AC6,AC7">Test save/load roundtrip preserves frame_rate, frame_count, frame data</idea>
      <idea ac="AC7">Test load_from_file() with invalid magic bytes returns error</idea>
      <idea ac="AC7">Test load_from_file() with non-existent file returns error</idea>
      <idea ac="AC7">Test load_from_file() with truncated file returns error</idea>
      <idea ac="AC9">cargo clippy --lib -- -D warnings passes</idea>
    </ideas>
  </tests>
</story-context>
