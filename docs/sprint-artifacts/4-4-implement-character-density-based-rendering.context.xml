<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>4.4</storyId>
    <title>Implement Character Density-Based Rendering</title>
    <status>drafted</status>
    <generatedAt>2025-11-21</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/4-4-implement-character-density-based-rendering.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer creating ASCII-art style visualizations</asA>
    <iWant>intensity-to-character mapping for gradients</iWant>
    <soThat>I can render smooth shading without binary thresholds</soThat>
    <tasks>
      - Task 1: Create Density Module Structure (AC: #1)
      - Task 2: Implement DensitySet Core Structure (AC: #1, #3)
      - Task 3: Implement Predefined Density Sets (AC: #2)
      - Task 4: Implement Grid Density Rendering (AC: #4)
      - Task 5: Add Comprehensive Unit Tests (AC: #8)
      - Task 6: Create Integration Test (AC: #6)
      - Task 7: Create Example Demonstration (AC: #7)
      - Task 8: Add Performance Benchmarks (AC: #8)
      - Task 9: Add Comprehensive Documentation (AC: #9)
      - Task 10: Code Quality and Finalization (AC: #9)
    </tasks>
  </story>

  <acceptanceCriteria>
    1. AC1: DensitySet Data Structure
       - Create `src/density/mod.rs` module
       - Implement `DensitySet` struct with character array and mapping function
       - Constructor validates non-empty character list, max 256 characters
       - Implements `map(&amp;self, intensity: f32) -> char` with linear interpolation
       - 0.0 → first char (lightest), 1.0 → last char (darkest)

    2. AC2: Predefined Density Character Sets
       - ASCII_DENSITY: Full 70-char gradient
       - SIMPLE_DENSITY: Simple 10-char gradient (` .:-=+*#%@`)
       - BLOCKS_DENSITY: Unicode block characters (` ░▒▓█`)
       - BRAILLE_DENSITY: Braille dots by density (`⠀⠁⠃⠇⠏⠟⠿⡿⣿`)
       - Each accessible via constructor function (DensitySet::ascii(), etc.)
       - Constants documented with rustdoc explaining density progression

    3. AC3: Intensity Mapping Algorithm
       - `DensitySet::map(intensity: f32) -> char` function
       - Clamps intensity to [0.0, 1.0] range (no panic for out-of-range)
       - Uses linear interpolation: `index = round(intensity * (len - 1))`
       - Returns character at calculated index
       - Handles edge cases: intensity 0.0 → index 0, intensity 1.0 → index len-1

    4. AC4: Render Intensity Buffer to Grid
       - Implement `BrailleGrid::render_density(&amp;mut self, intensity_buffer: &amp;[f32], density_set: &amp;DensitySet) -> Result&lt;(), DensityError>`
       - Validates buffer size matches grid size (width * height cells)
       - Maps each intensity value to character via density_set.map()
       - Renders character at corresponding grid cell position
       - Returns `DensityError::BufferSizeMismatch` if size doesn't match

    5. AC5: Custom Density Set Support
       - Developers can create custom density sets with arbitrary characters
       - Validation enforces 1-256 characters (returns error otherwise)
       - Custom sets work identically to predefined sets
       - Rustdoc includes example of creating custom set

    6. AC6: Integration with Image Pipeline
       - Density rendering consumes intensity buffers compatible with Epic 3 grayscale conversion
       - Example workflow: Load image → convert to grayscale → render as density characters
       - Integration test combines ImageRenderer grayscale output with density rendering

    7. AC7: Example Demonstration
       - Create `examples/density_demo.rs`
       - Demonstrates all 4 predefined density sets rendering same gradient
       - Shows custom density set creation
       - Displays visual comparison of ASCII vs Blocks vs Braille densities

    8. AC8: Comprehensive Testing
       - Unit tests achieve >80% code coverage
       - Test boundary values: intensity 0.0, 0.5, 1.0 map to expected characters
       - Test edge cases: out-of-range intensities (clamped), empty buffer, size mismatch
       - Test all predefined sets produce expected character progression
       - Test custom set creation with validation (empty list error, too many chars error)
       - Integration test: grayscale image → density rendering pipeline

    9. AC9: Production-Quality Documentation
       - Rustdoc on all public functions explaining purpose and algorithm
       - Code examples in rustdoc demonstrate common use cases
       - DensitySet struct documented with character progression explanation
       - Predefined sets documented with visual examples of density
       - Performance characteristics documented (O(n) where n = grid cells)
       - Error types documented with recovery strategies
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Functional Requirements - Character Density Rendering (FR28-FR31)</section>
        <snippet>FR28: The system maps intensity values (0.0 to 1.0) to character densities (sparse to dense). FR29: Developers can use predefined character density sets for ASCII-art style rendering. FR30: Developers can customize character density mappings. FR31: The system provides smooth gradients through density character selection.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Module Structure - density.rs</section>
        <snippet>src/density.rs - Character density rendering (Epic 4). Intensity → character mapping, predefined density sets. Integrates with BrailleGrid for rendering.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-4.md</path>
        <title>Epic 4 Technical Specification</title>
        <section>Data Models - DensitySet Structure (lines 173-211)</section>
        <snippet>DensitySet structure with characters: Vec&lt;char> and name: String. Implements map(&amp;self, intensity: f32) -> char for linear interpolation mapping. Predefined sets: ASCII_DENSITY_LIGHT (8 chars), ASCII_DENSITY_MEDIUM (70 chars), ASCII_DENSITY_HEAVY (Unicode blocks).</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-4.md</path>
        <title>Epic 4 Technical Specification</title>
        <section>Performance Targets (lines 390-404)</section>
        <snippet>Density rendering: &lt;10ms for full terminal (80×24 cells = 1920 cells). Expected performance: ~1μs per cell = 2ms total (well within target). No optimization expected - algorithm already optimal (single pass, array lookup).</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Stories Document</title>
        <section>Story 4.4: Implement Character Density-Based Rendering</section>
        <snippet>Intensity-to-character mapping for gradients. Predefined character density sets: ASCII_DENSITY (70 chars), SIMPLE_DENSITY (10 chars), BLOCKS_DENSITY (Unicode blocks), BRAILLE_DENSITY (braille progression). DensityRenderer struct with intensity_to_char() and render_grid() methods. Custom character sets supported.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/4-1-implement-bresenham-line-drawing-algorithm.md</path>
        <title>Story 4.1: Implement Bresenham Line Drawing</title>
        <section>Learnings - Module Structure Pattern</section>
        <snippet>Story 4.1 creates `src/primitives/` directory with `mod.rs` + `line.rs`. This establishes pattern for Epic 4 modules. Apply to 4.4: Create `src/density/` directory with `mod.rs` (parallel structure). Use same testing patterns: unit tests in same file with #[cfg(test)], comprehensive coverage >80%, example-driven development.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/grid.rs</path>
        <kind>core</kind>
        <symbol>BrailleGrid</symbol>
        <lines>1-400</lines>
        <reason>Core grid structure that density rendering will extend. Provides set_dot() API and grid state management. Density rendering will add render_density() method to this struct.</reason>
      </artifact>
      <artifact>
        <path>src/error.rs</path>
        <kind>error</kind>
        <symbol>DotmaxError</symbol>
        <lines>1-306</lines>
        <reason>Error type definitions. Story 4.4 will add DensityError variants: EmptyDensitySet, TooManyCharacters, BufferSizeMismatch. Follows thiserror pattern established in Epic 2.</reason>
      </artifact>
      <artifact>
        <path>src/primitives/mod.rs</path>
        <kind>module</kind>
        <symbol>primitives module</symbol>
        <lines>1-24</lines>
        <reason>Module structure pattern from Story 4.1. Demonstrates Epic 4 module organization: feature-based directory with mod.rs + implementation files. Density module will follow same pattern: src/density/mod.rs.</reason>
      </artifact>
      <artifact>
        <path>src/primitives/line.rs</path>
        <kind>implementation</kind>
        <symbol>draw_line, draw_line_thick</symbol>
        <lines>N/A</lines>
        <reason>Example of Epic 4 implementation pattern: algorithm implementation, comprehensive testing, error handling, documentation. Story 4.4 should follow same quality standards and code organization.</reason>
      </artifact>
      <artifact>
        <path>src/image/convert.rs</path>
        <kind>integration</kind>
        <symbol>grayscale conversion</symbol>
        <lines>N/A</lines>
        <reason>Epic 3 grayscale conversion outputs intensity buffers compatible with density rendering (AC6). Integration test will verify: grayscale image → intensity buffer → density rendering pipeline.</reason>
      </artifact>
      <artifact>
        <path>src/lib.rs</path>
        <kind>api</kind>
        <symbol>public API exports</symbol>
        <lines>N/A</lines>
        <reason>Public API surface definition. Story 4.4 will add: pub mod density; pub use density::DensitySet; Follows feature-flag pattern if density becomes optional in future.</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <core>
          <package name="thiserror" version="2.0" />
          <package name="tracing" version="0.1" />
        </core>
        <optional>
          <package name="image" version="0.25" feature="image" />
          <package name="imageproc" version="0.24" feature="image" />
        </optional>
        <dev>
          <package name="criterion" version="0.7" />
          <package name="tracing-subscriber" version="0.3" />
        </dev>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    - **Zero Panics Policy**: All density functions return Result types. Invalid inputs (empty character sets, buffer size mismatches, out-of-range intensities) return typed errors, never panic.
    - **Module Structure Consistency**: Follow src/primitives/ pattern from Story 4.1: Create src/density/ directory with mod.rs. Parallel structure for maintainability.
    - **Performance Target**: Density rendering must complete in &lt;10ms for 80×24 terminal (1920 cells). Expected: ~1μs per cell = 2ms total. Measure with criterion benchmarks.
    - **Memory Discipline**: No new allocations during rendering. Intensity buffer is borrowed, characters mapped in-place. &lt;500KB memory overhead per frame (NFR-P3).
    - **Integration Compatibility**: Intensity buffer format must match Epic 3 grayscale conversion output (Vec&lt;f32>, row-major order, normalized to [0.0, 1.0]).
    - **Forward Compatibility**: Design for future color support (Epic 5). DensitySet may include color mapping in future (intensity → Color). Keep API extensible.
    - **Test Coverage**: >80% code coverage matching Epic 3 quality standard. All error paths tested, all predefined sets validated, integration test with image pipeline.
    - **Documentation Quality**: Rustdoc on all public APIs with examples. Algorithm explanations reference standard practices (linear interpolation). Visual examples in density set docs.
  </constraints>

  <interfaces>
    <interface>
      <name>BrailleGrid::render_density</name>
      <kind>method</kind>
      <signature>pub fn render_density(&amp;mut self, intensity_buffer: &amp;[f32], density_set: &amp;DensitySet) -> Result&lt;(), DensityError></signature>
      <path>src/density/mod.rs (to be created)</path>
      <purpose>Renders intensity buffer using character density mapping. Main API for developers to convert grayscale intensities to ASCII-art style characters on grid.</purpose>
    </interface>
    <interface>
      <name>DensitySet::new</name>
      <kind>constructor</kind>
      <signature>pub fn new(name: String, characters: Vec&lt;char>) -> Result&lt;Self, DensityError></signature>
      <path>src/density/mod.rs</path>
      <purpose>Creates custom density set with validation. Enforces 1-256 character limit, non-empty character list. Returns EmptyDensitySet or TooManyCharacters error if invalid.</purpose>
    </interface>
    <interface>
      <name>DensitySet::map</name>
      <kind>method</kind>
      <signature>pub fn map(&amp;self, intensity: f32) -> char</signature>
      <path>src/density/mod.rs</path>
      <purpose>Maps single intensity value [0.0, 1.0] to character using linear interpolation. Clamps out-of-range values. Core algorithm: index = round(intensity * (len - 1)).</purpose>
    </interface>
    <interface>
      <name>DensitySet::ascii, simple, blocks, braille</name>
      <kind>constructor</kind>
      <signature>pub fn ascii() -> Self (and variants)</signature>
      <path>src/density/mod.rs</path>
      <purpose>Predefined density set constructors. Provide 4 common character progressions: ASCII (70 chars), SIMPLE (10 chars), BLOCKS (Unicode), BRAILLE (braille dots). Unwrap safe because predefined sets are validated.</purpose>
    </interface>
    <interface>
      <name>BrailleGrid::set_dot</name>
      <kind>method</kind>
      <signature>pub fn set_dot(&amp;mut self, x: usize, y: usize) -> Result&lt;(), DotmaxError></signature>
      <path>src/grid.rs (existing)</path>
      <purpose>Sets individual dot on grid. Used internally by density rendering to draw characters. Density module will call this to manipulate grid state after mapping intensities to characters.</purpose>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Epic 3 established >80% code coverage standard for image rendering pipeline. Story 4.4 must match this quality bar. All public APIs tested with unit tests. Integration test verifies compatibility with Epic 3 grayscale conversion. Performance benchmarks validate &lt;10ms target for full terminal rendering. Error paths tested comprehensively (empty sets, size mismatches, out-of-range intensities). Visual validation via examples/density_demo.rs (manual inspection). Test organization: Unit tests in src/density/mod.rs with #[cfg(test)], integration tests in tests/density_integration_tests.rs, benchmarks in benches/density.rs. Follow Story 4.1 testing pattern.
    </standards>
    <locations>
      - src/density/mod.rs (unit tests in #[cfg(test)] module)
      - tests/density_integration_tests.rs (or add to existing integration tests)
      - benches/density.rs (or add to benches/primitives.rs)
    </locations>
    <ideas>
      - Unit: Test DensitySet::new() validation (empty list → error, 257 chars → error, 1-256 chars → success)
      - Unit: Test DensitySet::map() boundary values (0.0 → first char, 1.0 → last char, 0.5 → middle char ±1 index)
      - Unit: Test DensitySet::map() clamping (-0.5 → first char, 1.5 → last char, NaN → clamped behavior)
      - Unit: Test all predefined sets (ASCII, SIMPLE, BLOCKS, BRAILLE) produce expected character progression
      - Unit: Test render_density() buffer size validation (size mismatch → BufferSizeMismatch error with diagnostic)
      - Unit: Test render_density() successful rendering with valid buffer (verify characters set on grid)
      - Integration: Load sample image using Epic 3 ImageRenderer → convert to grayscale → extract intensity buffer → render using DensitySet::ascii() → verify grid contains density characters
      - Integration: Test with multiple density sets (ascii, simple, blocks, braille) on same grayscale image
      - Benchmark: DensitySet::map() for single intensity value (baseline performance)
      - Benchmark: render_density() for full terminal-sized buffer (80×24 = 1920 cells) - verify &lt;10ms target
      - Benchmark: Vary buffer sizes (small 10×10, medium 40×24, large 80×48) to understand scaling characteristics
      - Example: Generate synthetic horizontal gradient (0.0 to 1.0) → render with all 4 predefined sets → visual comparison
      - Example: Create custom density set (e.g., ' ', 'o', 'O', '@') → demonstrate same gradient → show progression
    </ideas>
  </tests>
</story-context>
