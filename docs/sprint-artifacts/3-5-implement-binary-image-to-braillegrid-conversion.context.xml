<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.5</storyId>
    <title>Implement Binary Image to BrailleGrid Conversion</title>
    <status>drafted</status>
    <generatedAt>2025-11-19</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/3-5-implement-binary-image-to-braillegrid-conversion.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer rendering processed images to terminals</asA>
    <iWant>conversion from binary pixel data to braille dot patterns</iWant>
    <soThat>images display as braille characters</soThat>
    <tasks>
- Task 1: Create module structure (src/image/mapper.rs, add to mod.rs, feature gate)
- Task 2: Implement pixels_to_braille function signature and validation
- Task 3: Create BrailleGrid for output
- Task 4: Implement 2×4 pixel block iteration
- Task 5: Implement pixel-to-dot value mapping
- Task 6: Implement braille dot position mapping
- Task 7: Return completed BrailleGrid
- Task 8: Error handling for edge cases
- Task 9: Unit tests for pixel mapping correctness
- Task 10: Unit tests for padding and edge cases
- Task 11: Integration tests with full pipeline
- Task 12: Visual regression test
- Task 13: Performance benchmarks
- Task 14: Documentation and examples
- Task 15: Export public API
- Task 16: Validation and cleanup
    </tasks>
  </story>

  <acceptanceCriteria>
AC1: BrailleConverter Module and API Structure
- Module at src/image/mapper.rs
- Public API exported from src/image/mod.rs
- Signature: pixels_to_braille(binary: &BinaryImage, cell_width: usize, cell_height: usize) -> Result<BrailleGrid, DotmaxError>
- Feature-gated behind #[cfg(feature = "image")]
- Clear documentation of pixel-to-dot mapping algorithm

AC2: 2×4 Pixel Block to Braille Cell Mapping
- Maps every 2×4 pixel region to one braille cell (8 dots per cell)
- Pixel position within block maps to correct braille dot index
- Dot indexing follows Unicode braille standard (U+2800-U+28FF pattern)
- Black pixel (true in BinaryImage) → dot ON, white pixel (false) → dot OFF
- Handles images not perfectly divisible by 2×4 (pad with white pixels or truncate)

AC3: Integration with BrailleGrid from Epic 2
- Creates BrailleGrid with correct dimensions (image_width_pixels / 2, image_height_pixels / 4)
- Calls BrailleGrid::set_dot(x, y, value) for each pixel-to-dot mapping
- No direct manipulation of grid internals (uses public API from Story 2.1)
- Returns fully populated BrailleGrid ready for terminal rendering

AC4: Edge Case Handling
- Empty images (0×0) return error with descriptive message
- Very small images (1×1, 2×2) handled correctly (may result in single cell)
- Images not divisible by 2×4: pad bottom/right with white pixels to complete cells
- Very large images: validate against BrailleGrid maximum dimensions
- Zero panics guarantee maintained

AC5: Integration with Image Pipeline
- Works with BinaryImage output from Story 3.3 (threshold) or Story 3.4 (dither)
- Completes the image rendering pipeline: Load → Resize → Grayscale → Dither/Threshold → Map to Braille → Render
- Output BrailleGrid can be passed directly to TerminalRenderer::render() from Story 2.3
- Feature-gated with #[cfg(feature = "image")]

AC6: Performance Targets
- Braille mapping completes in <10ms for 160×96 pixel image (80×24 cells)
- Scales efficiently to larger terminals (200×50 cells, 400×200 pixels)
- Memory efficient: no intermediate buffers, direct pixel→dot conversion
- Benchmark created with criterion for performance validation

AC7: Error Handling
- Zero panics guarantee maintained
- Invalid dimensions return DotmaxError::InvalidImageDimensions
- Grid creation failures propagate as DotmaxError::GridCreation
- Descriptive error messages for debugging
- All error paths covered with tests

AC8: Testing and Quality Validation
- Unit tests with synthetic patterns (checkerboard, stripes, gradients)
- Known pattern tests: verify specific pixel blocks map to expected braille characters
- Edge case tests (1×1, empty, not-divisible-by-2×4, very large)
- Integration test: full pipeline (load image → resize → grayscale → dither → map to braille → verify output)
- Visual regression test: render known image, compare braille output
- Test coverage >80% for mapper module

AC9: Documentation and Examples
- Rustdoc for pixels_to_braille() with detailed explanation of 2×4 mapping
- Example showing pixel block → braille dot conversion visually
- Integration example showing full image-to-terminal pipeline
- Document padding strategy for non-divisible dimensions
- Performance characteristics documented
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification - 2D Image Rendering Pipeline</title>
        <section>Services and Modules - src/image/mapper.rs</section>
        <snippet>mapper.rs: Pixels → braille dots (2×4 blocks) | Input: BinaryImage | Output: BrailleGrid | Owner: Story 3.5</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification - 2D Image Rendering Pipeline</title>
        <section>APIs and Interfaces - mapper.rs</section>
        <snippet>pub fn pixels_to_braille(binary: &BinaryImage, cell_width: usize, cell_height: usize) -> Result<BrailleGrid, DotmaxError></snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification - 2D Image Rendering Pipeline</title>
        <section>Workflows and Sequencing - Step 7: Map to Braille</section>
        <snippet>mapper.rs: Group pixels into 2×4 blocks, convert pixel pattern to braille dot pattern, call BrailleGrid::set_dot() for each dot position</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification - 2D Image Rendering Pipeline</title>
        <section>Performance/Per-Stage Budget Allocation</section>
        <snippet>Braille mapping: <10ms target. Total pipeline <50ms.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Pattern 1: Braille Dot Matrix Mapping</section>
        <snippet>BrailleGrid stores dots as packed bits (8 dots per byte). 2×4 dot matrix per terminal cell. Dot coordinates: cell_x = x / 2, cell_y = y / 4.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Pattern 2: Image-to-Braille Conversion Pipeline</section>
        <snippet>Step 7: Map to Braille - mapper.rs groups pixels into 2×4 blocks, maps each pixel to corresponding dot, calls set_dot() for each position.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/grid.rs</path>
        <kind>module</kind>
        <symbol>BrailleGrid</symbol>
        <lines>96-300</lines>
        <reason>Core BrailleGrid struct from Epic 2. Story 3.5 uses BrailleGrid::new() and set_dot() API to populate grid with pixel data.</reason>
      </artifact>
      <artifact>
        <path>src/grid.rs</path>
        <kind>function</kind>
        <symbol>BrailleGrid::set_dot</symbol>
        <lines>150-180</lines>
        <reason>Critical API for setting individual dots. Story 3.5 calls this for each pixel in 2×4 blocks. Formula: dot_index = dot_x * 4 + dot_y.</reason>
      </artifact>
      <artifact>
        <path>src/image/threshold.rs</path>
        <kind>struct</kind>
        <symbol>BinaryImage</symbol>
        <lines>71-133</lines>
        <reason>Input type for pixels_to_braille(). Contains width, height, pixels: Vec<bool>. true=black, false=white. Output from Story 3.3/3.4.</reason>
      </artifact>
      <artifact>
        <path>src/image/dither.rs</path>
        <kind>module</kind>
        <symbol>apply_dithering</symbol>
        <lines>1-100</lines>
        <reason>Provides BinaryImage output from Floyd-Steinberg, Bayer, Atkinson algorithms. Story 3.5 consumes this output.</reason>
      </artifact>
      <artifact>
        <path>src/image/threshold.rs</path>
        <kind>function</kind>
        <symbol>auto_threshold</symbol>
        <lines>200-250</lines>
        <reason>Alternative to dithering. Produces BinaryImage via Otsu thresholding. Story 3.5 handles both dithered and non-dithered BinaryImages.</reason>
      </artifact>
      <artifact>
        <path>src/image/mod.rs</path>
        <kind>module</kind>
        <symbol>mod.rs</symbol>
        <lines>1-50</lines>
        <reason>Public API surface for image module. Story 3.5 adds pixels_to_braille export here with feature gate.</reason>
      </artifact>
      <artifact>
        <path>src/error.rs</path>
        <kind>enum</kind>
        <symbol>DotmaxError</symbol>
        <lines>1-100</lines>
        <reason>Error type for all public APIs. Story 3.5 may add InvalidImageDimensions or GridCreation variants if not already present.</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <package name="image" version="0.25" reason="DynamicImage, GrayImage types used in pipeline" />
        <package name="imageproc" version="0.24" reason="Image processing algorithms" />
        <package name="ratatui" version="0.29" reason="Terminal UI framework for rendering" />
        <package name="crossterm" version="0.29" reason="Cross-platform terminal I/O" />
        <package name="thiserror" version="2.0" reason="Error handling derive macros for DotmaxError" />
        <package name="tracing" version="0.1" reason="Structured logging for debugging and observability" />
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
- Feature Gate: All mapper.rs code must be behind #[cfg(feature = "image")]
- Zero Panics: All public functions return Result<T, DotmaxError>, no .unwrap() or .expect()
- Use BrailleGrid Public API: Call BrailleGrid::set_dot(x, y, value), do NOT manipulate dots vec directly
- Coordinate System: Pixel (x, y) maps to Dot (x, y) 1:1, BrailleGrid handles cell conversion internally
- Padding Strategy: Images not divisible by 2×4 pad bottom/right with white pixels (false)
- Error Handling: Return InvalidImageDimensions for 0×0 or oversized images
- Performance: <10ms for 160×96 pixel image (80×24 braille grid)
- Memory: No intermediate buffers, direct pixel→dot conversion
- Testing: >80% test coverage, unit tests for known patterns, edge cases, integration tests for pipeline
- Documentation: Rustdoc with ASCII art diagram of 2×4 pixel block → braille cell mapping
  </constraints>

  <interfaces>
    <interface>
      <name>BrailleGrid::new</name>
      <kind>constructor</kind>
      <signature>pub fn new(width: usize, height: usize) -> Self</signature>
      <path>src/grid.rs</path>
    </interface>
    <interface>
      <name>BrailleGrid::set_dot</name>
      <kind>method</kind>
      <signature>pub fn set_dot(&mut self, x: usize, y: usize, value: bool)</signature>
      <path>src/grid.rs</path>
    </interface>
    <interface>
      <name>BrailleGrid dimensions</name>
      <kind>method</kind>
      <signature>pub fn width(&self) -> usize, pub fn height(&self) -> usize</signature>
      <path>src/grid.rs</path>
    </interface>
    <interface>
      <name>BinaryImage struct</name>
      <kind>struct</kind>
      <signature>pub struct BinaryImage { pub width: u32, pub height: u32, pub pixels: Vec<bool> }</signature>
      <path>src/image/threshold.rs:71</path>
    </interface>
    <interface>
      <name>apply_dithering</name>
      <kind>function</kind>
      <signature>pub fn apply_dithering(gray: &GrayImage, method: DitheringMethod) -> Result<BinaryImage, DotmaxError></signature>
      <path>src/image/dither.rs</path>
    </interface>
    <interface>
      <name>auto_threshold</name>
      <kind>function</kind>
      <signature>pub fn auto_threshold(image: &DynamicImage) -> BinaryImage</signature>
      <path>src/image/threshold.rs</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
Story 3.5 follows the exceptional testing standards from Story 3.4 (38 tests, >80% coverage):
- Unit tests in #[cfg(test)] mod tests in mapper.rs
- Known-value testing: verify exact pixel patterns map to expected braille characters
- Edge case tests: empty images, 1×1, padding scenarios, very large images
- Integration tests: full pipeline (load → resize → grayscale → dither → map to braille)
- Visual tests: render known image, compare braille output
- Performance benchmarks: criterion benchmarks for <10ms target validation
- All tests use tracing-subscriber for debug output when RUST_LOG=debug
    </standards>
    <locations>
- src/image/mapper.rs - Unit tests in #[cfg(test)] mod
- tests/image_rendering_tests.rs - Integration tests for full pipeline
- benches/image_conversion.rs - Performance benchmarks (or create benches/mapper.rs)
    </locations>
    <ideas>
Test Idea 1 (AC2): Test all-black 2×4 block maps to braille cell with all 8 dots ON
Test Idea 2 (AC2): Test all-white 2×4 block maps to braille cell with all 8 dots OFF
Test Idea 3 (AC2): Test checkerboard pattern maps to alternating dots
Test Idea 4 (AC4): Test 5×5 image pads to 6×8 (3×2 grid)
Test Idea 5 (AC4): Test 0×0 image returns InvalidImageDimensions error
Test Idea 6 (AC4): Test 1×1 image creates 1×1 grid with 1 dot
Test Idea 7 (AC8): Integration test: load → resize → grayscale → dither (Floyd-Steinberg) → map → verify grid dimensions
Test Idea 8 (AC8): Integration test: load → resize → grayscale → threshold → map → verify grid populated
Test Idea 9 (AC6): Benchmark 160×96 pixel image mapping, verify <10ms
Test Idea 10 (AC2): Test pixel (0,0) maps to dot (0,0), pixel (1,0) maps to dot (1,0), etc.
Test Idea 11 (AC3): Verify BrailleGrid created with correct dimensions for various image sizes
Test Idea 12 (AC7): Test all error paths return descriptive DotmaxError variants
    </ideas>
  </tests>
</story-context>
