<?xml version="1.0" encoding="UTF-8"?>
<story-context version="1.0" generated="2025-11-24">
  <meta>
    <story-id>5.2</story-id>
    <story-key>5-2-implement-rgb-to-ansi-color-conversion</story-key>
    <title>Implement RGB-to-ANSI Color Conversion</title>
    <epic>Epic 5: Advanced Color Support</epic>
    <status>drafted</status>
    <priority>high</priority>
    <estimated-points>3</estimated-points>
    <predecessor-stories>
      <story id="5.1">Implement Terminal Color Capability Detection (completed)</story>
    </predecessor-stories>
    <successor-stories>
      <story id="5.3">Implement Adaptive Color Mode Selection</story>
    </successor-stories>
  </meta>

  <summary>
    This story implements RGB to ANSI color conversion algorithms that enable automatic
    downgrading of 24-bit RGB colors to ANSI 256-color or ANSI 16-color palettes based
    on terminal capabilities detected in Story 5.1.
  </summary>

  <acceptance-criteria>
    <criterion id="AC1" testable="true">
      Create `rgb_to_ansi256(r, g, b) -> u8` function using standard ANSI 256-color cube formula:
      - Colors 0-15: Standard ANSI colors (not used in conversion)
      - Colors 16-231: 6x6x6 color cube (r*36 + g*6 + b + 16)
      - Colors 232-255: 24-step grayscale ramp
    </criterion>
    <criterion id="AC2" testable="true">
      Create `rgb_to_ansi16(r, g, b) -> u8` function mapping to basic 16-color palette
      using perceptual color distance (grayscale threshold + hue matching)
    </criterion>
    <criterion id="AC3" testable="true">
      Create `ColorConverter` struct with methods:
      - `convert(color: Color, target: ColorCapability) -> AnsiColor`
      - Handles all ColorCapability variants from Story 5.1
    </criterion>
    <criterion id="AC4" testable="true">
      Support grayscale detection and optimization:
      - Near-grayscale colors (r≈g≈b within threshold) use grayscale ramp (232-255)
      - Improves visual fidelity on terminals with limited colors
    </criterion>
    <criterion id="AC5" testable="true">
      Unit tests for all 256 ANSI colors round-trip conversion:
      - `ansi256_to_rgb(rgb_to_ansi256(r, g, b))` should be "close" to (r, g, b)
      - Define "close" as perceptual distance threshold
    </criterion>
    <criterion id="AC6" testable="true">
      Performance benchmark: conversion must process >1M colors/second
    </criterion>
  </acceptance-criteria>

  <technical-requirements>
    <requirement id="TR1">Use ColorCapability enum from Story 5.1 (src/utils/terminal_caps.rs)</requirement>
    <requirement id="TR2">Create new module: src/utils/color_convert.rs</requirement>
    <requirement id="TR3">Export conversion functions from src/utils/mod.rs</requirement>
    <requirement id="TR4">Follow existing Color struct from src/grid.rs</requirement>
    <requirement id="TR5">Add benchmark to benches/color_rendering.rs</requirement>
    <requirement id="TR6">Zero panics policy - all functions return well-defined results</requirement>
  </technical-requirements>

  <architecture-context>
    <file-structure>
      <file path="src/utils/mod.rs" action="modify">Add pub mod color_convert</file>
      <file path="src/utils/color_convert.rs" action="create">New RGB-ANSI conversion module</file>
      <file path="src/lib.rs" action="modify">Re-export AnsiColor and ColorConverter</file>
      <file path="benches/color_rendering.rs" action="modify">Add conversion benchmarks</file>
    </file-structure>

    <dependencies>
      <internal>
        <dep module="grid::Color" purpose="RGB color representation" />
        <dep module="utils::terminal_caps::ColorCapability" purpose="Target color depth" />
      </internal>
      <external>
        <dep crate="none" reason="Pure Rust implementation - no additional dependencies" />
      </external>
    </dependencies>
  </architecture-context>

  <existing-code-context>
    <module name="Color" path="src/grid.rs" lines="31-62">
      <summary>
        RGB color representation for braille cells. Has r, g, b fields (u8),
        constructors rgb(), black(), white(). Derives Debug, Clone, Copy, PartialEq, Eq, Hash.
      </summary>
      <interface>
        pub struct Color { pub r: u8, pub g: u8, pub b: u8 }
        pub const fn rgb(r: u8, g: u8, b: u8) -> Self
        pub const fn black() -> Self
        pub const fn white() -> Self
      </interface>
    </module>

    <module name="ColorCapability" path="src/utils/terminal_caps.rs" lines="69-123">
      <summary>
        Terminal color capability levels enum from Story 5.1.
        Variants: Monochrome, Ansi16, Ansi256, TrueColor.
        Has supports_color() and supports_truecolor() methods.
        Cached detection via detect_color_capability().
      </summary>
      <interface>
        pub enum ColorCapability { Monochrome, Ansi16, Ansi256, TrueColor }
        pub fn supports_color(&amp;self) -> bool
        pub fn supports_truecolor(&amp;self) -> bool
        pub fn detect() -> Self
      </interface>
    </module>

    <module name="TerminalRenderer" path="src/render.rs" lines="273-578">
      <summary>
        Terminal renderer that uses ratatui. Currently renders colors using
        ratatui::style::Color::Rgb(r, g, b) directly (line 452-454).
        This story will enable it to use converted ANSI colors based on capability.
      </summary>
      <integration-point>
        Line 448-458: Color rendering in render() method.
        Currently: Color::Rgb(color.r, color.g, color.b)
        After Story 5.3: Will use ColorConverter to select appropriate color.
      </integration-point>
    </module>

    <module name="utils::mod" path="src/utils/mod.rs">
      <summary>Utility module exposing terminal_caps submodule.</summary>
      <integration-point>Add: pub mod color_convert;</integration-point>
    </module>
  </existing-code-context>

  <implementation-guidance>
    <algorithm name="RGB to ANSI 256">
      <description>Standard 6x6x6 color cube conversion</description>
      <pseudocode>
fn rgb_to_ansi256(r: u8, g: u8, b: u8) -> u8 {
    // Check for grayscale first (improves visual fidelity)
    if is_grayscale(r, g, b) {
        // Map to grayscale ramp (232-255)
        let gray = (r as u16 + g as u16 + b as u16) / 3;
        // 24 steps from 8 to 238, step = 10
        let index = (gray.saturating_sub(8) / 10).min(23);
        return 232 + index as u8;
    }

    // Convert to 6x6x6 color cube (colors 16-231)
    let r6 = (r as u16 * 5 / 255) as u8;  // 0-5
    let g6 = (g as u16 * 5 / 255) as u8;  // 0-5
    let b6 = (b as u16 * 5 / 255) as u8;  // 0-5

    16 + 36 * r6 + 6 * g6 + b6
}

fn is_grayscale(r: u8, g: u8, b: u8) -> bool {
    let max = r.max(g).max(b);
    let min = r.min(g).min(b);
    max - min &lt; 8  // Threshold for near-grayscale
}
      </pseudocode>
    </algorithm>

    <algorithm name="RGB to ANSI 16">
      <description>Map to basic 16-color palette using brightness and hue</description>
      <pseudocode>
// ANSI 16-color palette:
// 0: Black, 1: Red, 2: Green, 3: Yellow
// 4: Blue, 5: Magenta, 6: Cyan, 7: White
// 8-15: Bright variants

fn rgb_to_ansi16(r: u8, g: u8, b: u8) -> u8 {
    let brightness = (r as u16 + g as u16 + b as u16) / 3;
    let is_bright = brightness > 127;

    // Determine dominant color channel
    let base = match (r > 127, g > 127, b > 127) {
        (false, false, false) => 0,  // Black
        (true, false, false) => 1,   // Red
        (false, true, false) => 2,   // Green
        (true, true, false) => 3,    // Yellow
        (false, false, true) => 4,   // Blue
        (true, false, true) => 5,    // Magenta
        (false, true, true) => 6,    // Cyan
        (true, true, true) => 7,     // White
    };

    if is_bright &amp;&amp; base &lt; 7 { base + 8 } else { base }
}
      </pseudocode>
    </algorithm>

    <data-structure name="AnsiColor">
      <description>Represents a color in various ANSI formats</description>
      <definition>
pub enum AnsiColor {
    /// True color RGB (24-bit)
    Rgb(u8, u8, u8),
    /// ANSI 256-color palette index
    Ansi256(u8),
    /// ANSI 16-color palette index
    Ansi16(u8),
    /// No color (monochrome)
    None,
}
      </definition>
    </data-structure>

    <data-structure name="ColorConverter">
      <description>Stateless converter struct for ergonomic API</description>
      <definition>
pub struct ColorConverter;

impl ColorConverter {
    /// Convert RGB color to target capability
    pub fn convert(color: Color, target: ColorCapability) -> AnsiColor {
        match target {
            ColorCapability::TrueColor => AnsiColor::Rgb(color.r, color.g, color.b),
            ColorCapability::Ansi256 => AnsiColor::Ansi256(rgb_to_ansi256(color.r, color.g, color.b)),
            ColorCapability::Ansi16 => AnsiColor::Ansi16(rgb_to_ansi16(color.r, color.g, color.b)),
            ColorCapability::Monochrome => AnsiColor::None,
        }
    }
}
      </definition>
    </data-structure>
  </implementation-guidance>

  <testing-strategy>
    <unit-tests>
      <test name="test_rgb_to_ansi256_black">rgb_to_ansi256(0,0,0) returns grayscale 232</test>
      <test name="test_rgb_to_ansi256_white">rgb_to_ansi256(255,255,255) returns grayscale 255 or near</test>
      <test name="test_rgb_to_ansi256_pure_red">rgb_to_ansi256(255,0,0) returns 196 (color cube)</test>
      <test name="test_rgb_to_ansi256_pure_green">rgb_to_ansi256(0,255,0) returns 46</test>
      <test name="test_rgb_to_ansi256_pure_blue">rgb_to_ansi256(0,0,255) returns 21</test>
      <test name="test_rgb_to_ansi256_grayscale_ramp">Test full 232-255 grayscale mapping</test>
      <test name="test_rgb_to_ansi16_basic_colors">All 16 basic colors map correctly</test>
      <test name="test_rgb_to_ansi16_boundary_cases">Test boundary between bright/dim variants</test>
      <test name="test_converter_truecolor">TrueColor returns Rgb variant unchanged</test>
      <test name="test_converter_ansi256">Ansi256 capability triggers rgb_to_ansi256</test>
      <test name="test_converter_ansi16">Ansi16 capability triggers rgb_to_ansi16</test>
      <test name="test_converter_monochrome">Monochrome returns AnsiColor::None</test>
      <test name="test_round_trip_conversion">Verify visual fidelity of round-trip</test>
    </unit-tests>

    <benchmarks>
      <benchmark name="bench_rgb_to_ansi256" target=">1M/sec">
        Convert 1M random RGB values to ANSI 256
      </benchmark>
      <benchmark name="bench_rgb_to_ansi16" target=">5M/sec">
        Convert 1M random RGB values to ANSI 16
      </benchmark>
      <benchmark name="bench_color_converter" target=">1M/sec">
        ColorConverter::convert with mixed capabilities
      </benchmark>
    </benchmarks>
  </testing-strategy>

  <quality-checklist>
    <item>All public functions have doc comments with examples</item>
    <item>No panics - all edge cases return valid results</item>
    <item>cargo clippy --all-features passes with no warnings</item>
    <item>cargo test passes (all new tests + existing tests)</item>
    <item>Benchmark meets >1M conversions/second target</item>
    <item>Color conversion is deterministic (same input = same output)</item>
    <item>Grayscale optimization provides visually pleasing results</item>
  </quality-checklist>

  <definition-of-done>
    <item>All acceptance criteria tests pass</item>
    <item>Code reviewed and merged to main</item>
    <item>CI pipeline passes (tests, clippy, fmt)</item>
    <item>Benchmark results documented</item>
    <item>Ready for Story 5.3 integration</item>
  </definition-of-done>

  <references>
    <ref type="story-context" path="/mnt/e/dotmax/docs/sprint-artifacts/5-1-implement-terminal-color-capability-detection.context.xml">Story 5.1 context (predecessor)</ref>
    <ref type="tech-spec" path="/mnt/e/dotmax/docs/sprint-artifacts/tech-spec-epic-5.md">Epic 5 Technical Specification</ref>
    <ref type="architecture" path="/mnt/e/dotmax/docs/architecture.md">Project Architecture</ref>
    <ref type="source" path="/mnt/e/dotmax/src/utils/terminal_caps.rs">ColorCapability implementation</ref>
    <ref type="source" path="/mnt/e/dotmax/src/grid.rs">Color struct</ref>
    <ref type="source" path="/mnt/e/dotmax/src/render.rs">TerminalRenderer (integration point)</ref>
    <ref type="external" url="https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit">ANSI 256-color reference</ref>
  </references>
</story-context>
