<story-context id="6-1-implement-frame-buffer-and-double-buffering" v="1.0">
  <metadata>
    <epicId>6</epicId>
    <storyId>1</storyId>
    <title>Implement Frame Buffer and Double Buffering</title>
    <status>drafted</status>
    <generatedAt>2025-11-24</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/6-1-implement-frame-buffer-and-double-buffering.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer creating flicker-free animations</asA>
    <iWant>double buffering for smooth frame transitions</iWant>
    <soThat>animations don't flicker or tear during updates</soThat>
    <tasks>
      <task id="1" title="Create Animation Module Structure" ac="1,8,9">
        <subtask id="1.1">Create src/animation/ directory</subtask>
        <subtask id="1.2">Create src/animation/mod.rs with module-level documentation</subtask>
        <subtask id="1.3">Create src/animation/frame_buffer.rs file</subtask>
        <subtask id="1.4">Add pub mod animation; to src/lib.rs (always enabled, no feature flag)</subtask>
        <subtask id="1.5">Add rustdoc explaining double-buffering pattern at module level</subtask>
      </task>
      <task id="2" title="Implement FrameBuffer Struct" ac="1">
        <subtask id="2.1">Define FrameBuffer struct with front: BrailleGrid and back: BrailleGrid fields</subtask>
        <subtask id="2.2">Implement FrameBuffer::new(width, height) constructor</subtask>
        <subtask id="2.3">Initialize both grids with BrailleGrid::new(width, height)</subtask>
        <subtask id="2.4">Add width/height accessor methods</subtask>
        <subtask id="2.5">Add rustdoc with struct-level documentation</subtask>
      </task>
      <task id="3" title="Implement get_back_buffer()" ac="2">
        <subtask id="3.1">Add pub fn get_back_buffer(&amp;mut self) -> &amp;mut BrailleGrid</subtask>
        <subtask id="3.2">Returns &amp;mut self.back</subtask>
        <subtask id="3.3">Add rustdoc with example showing drawing to back buffer</subtask>
      </task>
      <task id="4" title="Implement get_front_buffer()" ac="4">
        <subtask id="4.1">Add pub fn get_front_buffer(&amp;self) -> &amp;BrailleGrid</subtask>
        <subtask id="4.2">Returns &amp;self.front (immutable reference)</subtask>
        <subtask id="4.3">Add rustdoc explaining this is read-only access to displayed buffer</subtask>
      </task>
      <task id="5" title="Implement swap_buffers()" ac="3">
        <subtask id="5.1">Add pub fn swap_buffers(&amp;mut self)</subtask>
        <subtask id="5.2">Use std::mem::swap(&amp;mut self.front, &amp;mut self.back) for O(1) swap</subtask>
        <subtask id="5.3">Add rustdoc explaining the pointer-swap semantics</subtask>
        <subtask id="5.4">Document that previous back becomes new front</subtask>
      </task>
      <task id="6" title="Implement render()" ac="4">
        <subtask id="6.1">Add pub fn render(&amp;self, renderer: &amp;mut TerminalRenderer) -> Result&lt;(), DotmaxError&gt;</subtask>
        <subtask id="6.2">Call renderer.render(&amp;self.front)</subtask>
        <subtask id="6.3">Propagate any errors from TerminalRenderer</subtask>
        <subtask id="6.4">Add rustdoc with complete workflow example</subtask>
      </task>
      <task id="7" title="Write Unit Tests" ac="6">
        <subtask id="7.1">Create #[cfg(test)] mod tests in frame_buffer.rs</subtask>
        <subtask id="7.2">Test new() creates buffers with correct dimensions</subtask>
        <subtask id="7.3">Test get_back_buffer() returns mutable reference</subtask>
        <subtask id="7.4">Test swap_buffers() exchanges buffers correctly</subtask>
        <subtask id="7.5">Test content preservation: draw -> swap -> verify front has content</subtask>
        <subtask id="7.6">Test multiple sequential swaps maintain correct state</subtask>
        <subtask id="7.7">Test dimensions (1x1, 80x24, 200x50)</subtask>
        <subtask id="7.8">Test width() and height() return correct values</subtask>
      </task>
      <task id="8" title="Create Performance Benchmark" ac="7">
        <subtask id="8.1">Create benches/animation.rs</subtask>
        <subtask id="8.2">Add [[bench]] name = "animation" harness = false to Cargo.toml</subtask>
        <subtask id="8.3">Benchmark FrameBuffer::new(80, 24) creation</subtask>
        <subtask id="8.4">Benchmark swap_buffers() operation (target: &lt;1ms)</subtask>
        <subtask id="8.5">Benchmark swap_buffers() for large buffer (200x50)</subtask>
        <subtask id="8.6">Add benchmark group with proper measurement settings</subtask>
      </task>
      <task id="9" title="Create Visual Example" ac="5">
        <subtask id="9.1">Create examples/animation_buffer.rs</subtask>
        <subtask id="9.2">Implement bouncing ball physics (position, velocity, bounce on edges)</subtask>
        <subtask id="9.3">Use double-buffering workflow: clear back -> draw ball -> swap -> render</subtask>
        <subtask id="9.4">Add FPS calculation and display</subtask>
        <subtask id="9.5">Add Ctrl+C handler for graceful exit using crossterm events</subtask>
        <subtask id="9.6">Add comments explaining each step of the animation loop</subtask>
        <subtask id="9.7">Target 60fps with frame timing</subtask>
      </task>
      <task id="10" title="Update Module Exports" ac="9">
        <subtask id="10.1">Export FrameBuffer from src/animation/mod.rs</subtask>
        <subtask id="10.2">Re-export from src/lib.rs: pub use animation::FrameBuffer;</subtask>
        <subtask id="10.3">Verify public API is accessible from crate root</subtask>
      </task>
      <task id="11" title="Final Validation" ac="All">
        <subtask id="11.1">Run full test suite: cargo test --lib --all-features</subtask>
        <subtask id="11.2">Run clippy: cargo clippy --lib --example animation_buffer --bench animation -- -D warnings</subtask>
        <subtask id="11.3">Run rustdoc: RUSTDOCFLAGS="-D warnings" cargo doc --no-deps</subtask>
        <subtask id="11.4">Run doc tests: cargo test --doc</subtask>
        <subtask id="11.5">Run benchmark: cargo bench --bench animation</subtask>
        <subtask id="11.6">Manual test: Run example and verify smooth animation</subtask>
        <subtask id="11.7">All ACs verified with evidence</subtask>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <ac id="1" title="FrameBuffer::new() Creates Two BrailleGrid Buffers">
      FrameBuffer::new(width: usize, height: usize) -> Self in src/animation/frame_buffer.rs.
      Creates two BrailleGrid instances: front buffer (displayed) and back buffer (being prepared).
      Both buffers initialized with same dimensions.
      Returns FrameBuffer struct with owned buffers.
    </ac>
    <ac id="2" title="get_back_buffer() Returns Mutable Reference">
      pub fn get_back_buffer(&amp;mut self) -> &amp;mut BrailleGrid.
      Returns mutable reference to back buffer for drawing operations.
      Front buffer remains unchanged while drawing to back buffer.
      User can draw to back buffer using all BrailleGrid methods (set_dot, draw_line, etc.).
    </ac>
    <ac id="3" title="swap_buffers() Exchanges Front/Back in &lt;1ms">
      pub fn swap_buffers(&amp;mut self) performs instant swap.
      Implements pointer swap (not data copy) for O(1) performance.
      After swap: previous back becomes front, previous front becomes back.
      Benchmark validates &lt;1ms swap time.
    </ac>
    <ac id="4" title="render() Outputs Front Buffer via TerminalRenderer">
      pub fn render(&amp;self, renderer: &amp;mut TerminalRenderer) -> Result&lt;(), DotmaxError&gt;.
      Renders current front buffer to terminal.
      Supports both colored and non-colored grids.
      Returns error on terminal I/O failure.
    </ac>
    <ac id="5" title="Example animation_buffer.rs Demonstrates Bouncing Ball">
      Create examples/animation_buffer.rs.
      Demonstrates complete double-buffering workflow.
      Shows bouncing ball physics simulation.
      Uses: get_back_buffer() -> draw -> swap_buffers() -> render().
      Includes FPS display and graceful Ctrl+C exit.
    </ac>
    <ac id="6" title="Unit Tests Verify Buffer Swap Correctness">
      Test buffer creation with various dimensions (1x1, 80x24, 200x50).
      Test swap preserves content (draw to back, swap, verify front has content).
      Test multiple swaps maintain correct state.
      Test get_back_buffer returns correct buffer after swap.
      Minimum 8 unit tests covering all APIs.
    </ac>
    <ac id="7" title="Benchmark Confirms Swap &lt;1ms">
      Create benches/animation.rs with buffer swap microbenchmark.
      Benchmark swap_buffers() operation.
      Verify 95th percentile &lt; 1ms.
      Include buffer creation benchmark for baseline.
    </ac>
    <ac id="8" title="Zero Clippy Warnings in frame_buffer.rs">
      cargo clippy --lib -- -D warnings passes with zero warnings for animation module.
      No #[allow(...)] attributes except where justified with comment.
      Follows Rust naming conventions (snake_case functions, PascalCase types).
    </ac>
    <ac id="9" title="Rustdoc with Examples for All Public Methods">
      All public functions have /// doc comments.
      Each method includes at least one # Examples code block.
      Examples compile via cargo test --doc.
      Module-level documentation explains double-buffering concept.
      Zero rustdoc warnings: RUSTDOCFLAGS="-D warnings" cargo doc.
    </ac>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Pattern 3: Buffer Reuse for Animation</section>
        <snippet>BrailleGrid buffers are reused, not reallocated each frame. Target &lt;500KB memory overhead per frame. Critical for 60fps performance. AnimationRenderer uses stateful buffer reuse pattern.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Error Handling</section>
        <snippet>All public functions return Result&lt;T, DotmaxError&gt;. Use thiserror patterns (ADR 0002). render() returns Result&lt;(), DotmaxError&gt; for terminal I/O failure handling.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Module Structure</section>
        <snippet>src/animation.rs - Animation &amp; frames (Epic 6). Frame buffers, timing, loops. Feature-based module organization with one module per epic/feature.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-6.md</path>
        <title>Epic 6 Technical Specification</title>
        <section>Story 6.1 Detailed Design</section>
        <snippet>FrameBuffer API: new(w,h), get_back_buffer(), get_front_buffer(), swap_buffers() (&lt;1ms pointer swap), render(), width(), height(). Buffer swap time: &lt;1ms, Frame rate: 60fps sustained, Per-frame memory: &lt;500KB.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-6.md</path>
        <title>Epic 6 Technical Specification</title>
        <section>Double Buffering Workflow</section>
        <snippet>1. User calls get_back_buffer() 2. User draws to back buffer 3. swap_buffers() - instant pointer swap 4. render() - front buffer to terminal 5. Repeat</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Definitions</title>
        <section>Epic 6: Animation &amp; Frame Management</section>
        <snippet>Goal: Enable frame-by-frame animation playback, timing control, frame buffer management, pre-rendering optimization, and flicker-free updates. Support real-time animations at 60+ fps with minimal CPU overhead.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/grid.rs</path>
        <kind>core module</kind>
        <symbol>BrailleGrid</symbol>
        <lines>161-285</lines>
        <reason>Core buffer structure for front/back buffers. Provides new(), clear(), set_dot(), width(), height(), dimensions(), to_unicode_grid() methods that FrameBuffer wraps.</reason>
      </artifact>
      <artifact>
        <path>src/grid.rs</path>
        <kind>function</kind>
        <symbol>BrailleGrid::new(width, height)</symbol>
        <lines>206-243</lines>
        <reason>Constructor for creating BrailleGrid instances. FrameBuffer::new() will call this twice to create front and back buffers.</reason>
      </artifact>
      <artifact>
        <path>src/grid.rs</path>
        <kind>function</kind>
        <symbol>BrailleGrid::clear()</symbol>
        <lines>292-305</lines>
        <reason>Clears all dots in grid. Used by animation loop to clear back buffer before drawing new frame.</reason>
      </artifact>
      <artifact>
        <path>src/render.rs</path>
        <kind>core module</kind>
        <symbol>TerminalRenderer</symbol>
        <lines>273-578</lines>
        <reason>Terminal rendering abstraction. FrameBuffer::render() delegates to TerminalRenderer::render(&amp;self.front) for terminal output.</reason>
      </artifact>
      <artifact>
        <path>src/render.rs</path>
        <kind>function</kind>
        <symbol>TerminalRenderer::render(&amp;mut self, grid: &amp;BrailleGrid)</symbol>
        <lines>391-474</lines>
        <reason>Renders BrailleGrid to terminal via ratatui. FrameBuffer wraps this to render the front buffer.</reason>
      </artifact>
      <artifact>
        <path>src/error.rs</path>
        <kind>enum</kind>
        <symbol>DotmaxError</symbol>
        <lines>44-232</lines>
        <reason>Comprehensive error type for all dotmax operations. FrameBuffer::render() returns Result&lt;(), DotmaxError&gt;.</reason>
      </artifact>
      <artifact>
        <path>src/lib.rs</path>
        <kind>module root</kind>
        <symbol>pub mod, pub use</symbol>
        <lines>63-109</lines>
        <reason>Public API re-exports. Need to add: pub mod animation; and pub use animation::FrameBuffer;</reason>
      </artifact>
      <artifact>
        <path>benches/rendering.rs</path>
        <kind>benchmark</kind>
        <symbol>criterion benchmark pattern</symbol>
        <lines>1-80</lines>
        <reason>Reference for criterion.rs benchmark structure. Follow same pattern for benches/animation.rs with FrameBuffer benchmarks.</reason>
      </artifact>
      <artifact>
        <path>tests/integration_tests.rs</path>
        <kind>test</kind>
        <symbol>require_terminal! macro</symbol>
        <lines>14-25</lines>
        <reason>Test helper macro for graceful terminal availability handling. Reuse pattern in FrameBuffer integration tests.</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <package name="ratatui" version="0.29">Terminal UI framework - already in core dependencies</package>
        <package name="crossterm" version="0.29">Cross-platform terminal I/O - already in core dependencies</package>
        <package name="thiserror" version="2.0">Error handling derive macros - already in core dependencies</package>
        <package name="tracing" version="0.1">Structured logging - already in core dependencies</package>
        <package name="criterion" version="0.7" dev="true">Statistics-driven benchmarking - already in dev-dependencies</package>
        <package name="std::mem" version="stdlib">For std::mem::swap - O(1) buffer swap</package>
        <package name="std::time" version="stdlib">For Instant, Duration - frame timing in example</package>
        <package name="std::thread" version="stdlib">For thread::sleep - frame pacing in example</package>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint source="architecture.md">Buffer swap time: &lt;1ms (pointer swap, not data copy)</constraint>
    <constraint source="tech-spec-epic-6.md">Frame rate: 60fps sustained minimum</constraint>
    <constraint source="architecture.md">Per-frame memory: &lt;500KB overhead (reuse BrailleGrid buffers)</constraint>
    <constraint source="architecture.md">No unsafe code in animation implementation</constraint>
    <constraint source="architecture.md">All timing uses std::time (no external dependencies)</constraint>
    <constraint source="architecture.md">Sync-only API per ADR 0006 - no async in MVP</constraint>
    <constraint source="Cargo.toml">clippy all="deny", pedantic="warn", nursery="warn"</constraint>
    <constraint source="story">Zero clippy warnings in frame_buffer.rs</constraint>
    <constraint source="story">Zero rustdoc warnings</constraint>
    <constraint source="story">Minimum 8 unit tests covering all APIs</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>FrameBuffer API (from tech-spec)</name>
      <kind>struct and methods</kind>
      <signature>
impl FrameBuffer {
    pub fn new(width: usize, height: usize) -> Self;
    pub fn get_back_buffer(&amp;mut self) -> &amp;mut BrailleGrid;
    pub fn get_front_buffer(&amp;self) -> &amp;BrailleGrid;
    pub fn swap_buffers(&amp;mut self);  // &lt;1ms - pointer swap only
    pub fn render(&amp;self, renderer: &amp;mut TerminalRenderer) -> Result&lt;(), DotmaxError&gt;;
    pub fn width(&amp;self) -> usize;
    pub fn height(&amp;self) -> usize;
}
      </signature>
      <path>src/animation/frame_buffer.rs (NEW)</path>
    </interface>
    <interface>
      <name>BrailleGrid::new</name>
      <kind>constructor</kind>
      <signature>pub fn new(width: usize, height: usize) -> Result&lt;Self, DotmaxError&gt;</signature>
      <path>src/grid.rs:206</path>
    </interface>
    <interface>
      <name>BrailleGrid::clear</name>
      <kind>method</kind>
      <signature>pub fn clear(&amp;mut self)</signature>
      <path>src/grid.rs:292</path>
    </interface>
    <interface>
      <name>BrailleGrid dimension accessors</name>
      <kind>methods</kind>
      <signature>pub const fn width(&amp;self) -> usize; pub const fn height(&amp;self) -> usize;</signature>
      <path>src/grid.rs:249-258</path>
    </interface>
    <interface>
      <name>TerminalRenderer::render</name>
      <kind>method</kind>
      <signature>pub fn render(&amp;mut self, grid: &amp;BrailleGrid) -> Result&lt;(), DotmaxError&gt;</signature>
      <path>src/render.rs:392</path>
    </interface>
    <interface>
      <name>std::mem::swap</name>
      <kind>stdlib function</kind>
      <signature>pub fn swap&lt;T&gt;(x: &amp;mut T, y: &amp;mut T)</signature>
      <path>std::mem</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing follows established project patterns: Unit tests use #[cfg(test)] mod tests within each module file. Integration tests in tests/ directory use require_terminal! macro for graceful terminal availability handling. Benchmarks use criterion.rs with bench_function pattern and html_reports feature. Doc examples compile via cargo test --doc. Zero warnings enforced via RUSTDOCFLAGS="-D warnings".
    </standards>
    <locations>
      <location>src/animation/frame_buffer.rs - unit tests in #[cfg(test)] mod tests</location>
      <location>benches/animation.rs - criterion benchmarks for swap_buffers and creation</location>
      <location>tests/integration_tests.rs - potential integration tests with renderer</location>
    </locations>
    <ideas>
      <idea ac="1">test_new_creates_two_buffers_with_correct_dimensions - verify front.width() == width, back.width() == width</idea>
      <idea ac="1">test_new_dimensions_1x1 - edge case minimum dimensions</idea>
      <idea ac="1">test_new_dimensions_80x24 - standard terminal size</idea>
      <idea ac="1">test_new_dimensions_200x50 - large buffer stress test</idea>
      <idea ac="2">test_get_back_buffer_returns_mutable_reference - verify can call set_dot</idea>
      <idea ac="2">test_back_buffer_modifications_dont_affect_front - draw to back, verify front empty</idea>
      <idea ac="3">test_swap_buffers_exchanges_buffers - draw pattern to back, swap, verify front has pattern</idea>
      <idea ac="3">test_swap_buffers_double_swap_restores_original - swap twice, verify back has original content</idea>
      <idea ac="3">test_swap_performance_under_1ms - benchmark assertion for &lt;1ms</idea>
      <idea ac="4">test_render_delegates_to_terminal_renderer - mock or verify render called</idea>
      <idea ac="6">test_width_height_accessors_return_correct_values - verify accessor correctness</idea>
      <idea ac="7">bench_swap_buffers_80x24 - criterion benchmark target &lt;1ms</idea>
      <idea ac="7">bench_swap_buffers_200x50 - verify scales O(1)</idea>
      <idea ac="7">bench_frame_buffer_creation - baseline for buffer allocation</idea>
    </ideas>
  </tests>
</story-context>
