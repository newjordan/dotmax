<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.4</storyId>
    <title>Implement Dithering Algorithms (Floyd-Steinberg, Bayer, Atkinson)</title>
    <status>drafted</status>
    <generatedAt>2025-11-19</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/3-4-implement-dithering-algorithms-floyd-steinberg-bayer-atkinson.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer rendering images with limited binary output</asA>
    <iWant>multiple dithering algorithms to optimize visual quality</iWant>
    <soThat>braille images display smooth gradients and detail preservation</soThat>
    <tasks>
- Task 1: Create module structure and DitheringMethod enum (AC: 1, 5)
- Task 2: Implement Floyd-Steinberg dithering (AC: 2)
- Task 3: Implement Bayer matrix dithering (AC: 3)
- Task 4: Implement Atkinson dithering (AC: 4)
- Task 5: Create unified apply_dithering() function (AC: 1, 5)
- Task 6: Error handling and validation (AC: 6)
- Task 7: Unit tests for Floyd-Steinberg (AC: 7)
- Task 8: Unit tests for Bayer dithering (AC: 7)
- Task 9: Unit tests for Atkinson dithering (AC: 7)
- Task 10: Integration tests (AC: 7)
- Task 11: Performance benchmarks (AC: 8)
- Task 12: Visual comparison example (AC: 9)
- Task 13: Documentation and algorithm references (AC: 9)
- Task 14: Export public API (AC: 1)
- Task 15: Validation and cleanup (AC: All)
    </tasks>
  </story>

  <acceptanceCriteria>
1. DitheringMethod Enum and API Structure - DitheringMethod enum with variants (None, FloydSteinberg, Bayer, Atkinson), functions take &GrayImage and return BinaryImage, API supports method selection, module at src/image/dither.rs

2. Floyd-Steinberg Dithering Implementation - Error diffusion with coefficients (7/16, 3/16, 5/16, 1/16), diffuses to right and bottom pixels, handles edge cases, high-quality output, <15ms performance

3. Bayer Ordered Dithering Implementation - 8×8 Bayer matrix, standard pattern, fast ordered dithering, stateless/parallelizable, <10ms performance

4. Atkinson Dithering Implementation - Atkinson error diffusion with coefficients (1/8 to 6 neighbors, 2/8 discarded), softer artistic output, handles edge cases, <12ms performance

5. Integration with Image Pipeline - Works with GrayImage from Story 3.3, returns BinaryImage for Story 3.5, optional stage (can skip to thresholding), consistent input/output types, feature-gated behind #[cfg(feature = "image")]

6. Error Handling - Zero panics guarantee, graceful handling of invalid dimensions, returns DotmaxError::ProcessingError with context, descriptive error messages

7. Testing and Quality Validation - Unit tests for each algorithm, visual regression tests, edge case tests, integration test (load → resize → grayscale → dither → verify BinaryImage), >80% test coverage

8. Performance Targets - Floyd-Steinberg <15ms, Bayer <10ms, Atkinson <12ms (all for 160×96 image), benchmarks with criterion, validation via cargo bench

9. Documentation and Examples - Rustdoc for all public functions with examples, algorithm explanations with references (Floyd-Steinberg paper, Bayer matrix, Atkinson history), visual comparison example showing all three methods, performance characteristics documented
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic Technical Specification: 2D Image Rendering Pipeline</title>
        <section>Services and Modules - src/image/dither.rs</section>
        <snippet>Module responsibility: Floyd-Steinberg, Bayer, Atkinson dithering algorithms. Inputs: GrayImage, DitheringMethod. Outputs: BinaryImage. Performance budget: <15ms for Floyd-Steinberg (most expensive), <10ms for Bayer, <12ms for Atkinson.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic Technical Specification: 2D Image Rendering Pipeline</title>
        <section>Data Models and Contracts - DitheringMethod enum</section>
        <snippet>pub enum DitheringMethod { None, FloydSteinberg, Bayer, Atkinson }. None = direct threshold (no dithering), FloydSteinberg = error diffusion (best quality, slower), Bayer = ordered dithering (fast, good for gradients), Atkinson = error diffusion (Apple-style, softer).</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic Technical Specification: 2D Image Rendering Pipeline</title>
        <section>Workflows and Sequencing - Step 5: Dithering</section>
        <snippet>Pipeline step 5: Input GrayImage + DitheringMethod selection → dither.rs applies Floyd-Steinberg/Bayer/Atkinson/None → Output BinaryImage. If no dithering, skip to Step 6 (threshold). Dithering is optional stage for quality enhancement.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic Technical Specification: 2D Image Rendering Pipeline</title>
        <section>Per-Stage Budget Allocation</section>
        <snippet>Dithering stage budget: <15ms target (most expensive stage in pipeline). Floyd-Steinberg <15ms, Bayer <10ms, Atkinson <12ms. Total pipeline must stay <50ms, dithering is critical bottleneck to optimize.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>dotmax - Architecture Document</title>
        <section>Pattern 2: Image-to-Braille Conversion Pipeline</section>
        <snippet>Stage 5 of pipeline: Dithering. Input: GrayImage. Process: Apply Floyd-Steinberg/Bayer/Atkinson algorithms to distribute quantization error and maintain visual quality in binary conversion. Output: BinaryImage (boolean pixels). Performance critical: entire pipeline must complete in <50ms.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>dotmax - Architecture Document</title>
        <section>ADR 0002: Use thiserror for Error Handling</section>
        <snippet>All errors use DotmaxError enum with thiserror. Zero panics guarantee - all public functions return Result<T, DotmaxError>. Type-safe error matching for users. Clear error context and chaining.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>dotmax - Product Requirements Document</title>
        <section>Functional Requirements - FR15</section>
        <snippet>Developers can select dithering method (Floyd-Steinberg, Bayer, Atkinson, or none). Three industry-standard algorithms for different quality/speed trade-offs.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>dotmax - Product Requirements Document</title>
        <section>Non-Functional Requirements - NFR-P1</section>
        <snippet>Performance is make-or-break. Image-to-braille conversion: <25ms target, <50ms maximum for standard terminals (80×24). Must beat competitor performance. Numbers guide ALL optimization decisions.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/image/mod.rs</path>
        <kind>module</kind>
        <symbol>mod threshold, mod convert</symbol>
        <lines>1-84</lines>
        <reason>Module structure for image pipeline. Shows existing exports (to_grayscale, auto_threshold, BinaryImage). Need to add dither module and export DitheringMethod, apply_dithering.</reason>
      </artifact>
      <artifact>
        <path>src/image/convert.rs</path>
        <kind>module</kind>
        <symbol>to_grayscale</symbol>
        <lines>66-80</lines>
        <reason>Provides GrayImage input to dithering algorithms. Uses ITU-R BT.709 luminance conversion. Target performance: <2ms for 160×96 images.</reason>
      </artifact>
      <artifact>
        <path>src/image/threshold.rs</path>
        <kind>module</kind>
        <symbol>BinaryImage, otsu_threshold, apply_threshold, auto_threshold</symbol>
        <lines>71-327</lines>
        <reason>Defines BinaryImage output type (width, height, pixels: Vec<bool>). Provides auto_threshold() fallback for DitheringMethod::None. Pattern for binary conversion functions.</reason>
      </artifact>
      <artifact>
        <path>src/image/threshold.rs</path>
        <kind>struct</kind>
        <symbol>BinaryImage</symbol>
        <lines>71-133</lines>
        <reason>Output type for all dithering algorithms. Boolean pixels (true=black, false=white). Includes new(), get_pixel(), set_pixel() methods. Optimized for braille mapping.</reason>
      </artifact>
      <artifact>
        <path>src/image/threshold.rs</path>
        <kind>function</kind>
        <symbol>otsu_threshold</symbol>
        <lines>180-241</lines>
        <reason>Reference implementation for threshold calculation. Shows histogram-based algorithm pattern, performance optimization approach, comprehensive documentation style.</reason>
      </artifact>
      <artifact>
        <path>src/image/threshold.rs</path>
        <kind>function</kind>
        <symbol>apply_threshold</symbol>
        <lines>264-285</lines>
        <reason>Pattern for binary conversion: iterate pixels, apply decision rule, populate BinaryImage. Target performance: <2ms. Use as template for dithering functions.</reason>
      </artifact>
      <artifact>
        <path>src/image/threshold.rs</path>
        <kind>function</kind>
        <symbol>adjust_brightness, adjust_contrast, adjust_gamma</symbol>
        <lines>364-508</lines>
        <reason>Pattern for image adjustment functions with validation. Shows parameter validation, error handling (InvalidParameter variant), Result<GrayImage, DotmaxError> return type.</reason>
      </artifact>
      <artifact>
        <path>src/error.rs</path>
        <kind>enum</kind>
        <symbol>DotmaxError</symbol>
        <lines>44-148</lines>
        <reason>Error type for all operations. InvalidParameter variant (lines 142-148) for parameter validation. Add ProcessingError variant if needed for dithering failures.</reason>
      </artifact>
      <artifact>
        <path>src/error.rs</path>
        <kind>enum_variant</kind>
        <symbol>DotmaxError::InvalidParameter</symbol>
        <lines>142-148</lines>
        <reason>Error variant for invalid function parameters (brightness, contrast, gamma). Use for invalid dithering dimensions or parameters. Includes parameter_name, value, min, max fields.</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <dependency name="image" version="0.25">
          <types>GrayImage, Luma</types>
          <reason>GrayImage is input type for all dithering algorithms. Luma type for pixel values.</reason>
        </dependency>
        <dependency name="tracing" version="0.1">
          <functions>debug!, info!</functions>
          <reason>Structured logging for dithering operations. Debug level for algorithm steps, info for completion.</reason>
        </dependency>
        <dependency name="thiserror" version="2.0">
          <derive>Error</derive>
          <reason>DotmaxError enum uses thiserror for error handling. Zero panics guarantee.</reason>
        </dependency>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Zero panics guarantee: All public functions must return Result<T, DotmaxError>. No .unwrap() or .expect() in production code.</constraint>
    <constraint>Feature gate: All dithering code behind #[cfg(feature = "image")] to keep core library lightweight.</constraint>
    <constraint>Performance budget: Floyd-Steinberg <15ms, Bayer <10ms, Atkinson <12ms for 160×96 images. Measured with criterion benchmarks.</constraint>
    <constraint>Memory efficiency: Error buffers (Vec<f32> or Vec<i16>) must be dropped after use. No memory leaks, bounded allocations.</constraint>
    <constraint>Module location: src/image/dither.rs - follows pattern from threshold.rs and convert.rs. Single responsibility per module.</constraint>
    <constraint>Naming conventions: snake_case for functions (floyd_steinberg, bayer, atkinson, apply_dithering), PascalCase for DitheringMethod enum.</constraint>
    <constraint>Documentation: Every public function needs rustdoc with examples, algorithm explanation, performance notes, and academic references.</constraint>
    <constraint>Testing: >80% test coverage for dither module. Unit tests for each algorithm, edge cases (1×1, boundaries), integration tests for full pipeline.</constraint>
    <constraint>Cross-platform: Same deterministic output on Windows, Linux, macOS. CI tests verify consistency.</constraint>
    <constraint>Code quality: Zero clippy warnings at pedantic level. Formatted with rustfmt. Follows Rust idioms (ownership, borrowing).</constraint>
    <constraint>Error handling pattern: Use DotmaxError::InvalidParameter for invalid dimensions. Return descriptive error messages with context.</constraint>
    <constraint>Integration: Must work with existing GrayImage (from convert.rs) and BinaryImage (from threshold.rs). No new types needed.</constraint>
    <constraint>Tracing: Use tracing::debug! for algorithm steps (threshold values, matrix lookups), tracing::info! for completion. No trace! in hot paths.</constraint>
    <constraint>Algorithm correctness: Implement standard algorithms (Floyd-Steinberg 1976 paper, standard 8×8 Bayer matrix, Atkinson 1984 MacPaint). No custom variations.</constraint>
    <constraint>Threshold value: Use 127 as middle gray threshold for binary decision (< 128 is common industry practice).</constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>DitheringMethod</name>
      <kind>enum</kind>
      <signature>pub enum DitheringMethod { None, FloydSteinberg, Bayer, Atkinson }</signature>
      <path>src/image/dither.rs</path>
      <description>Algorithm selection enum. None = skip dithering and use auto_threshold, FloydSteinberg = error diffusion (best quality), Bayer = ordered dithering (fastest), Atkinson = partial error diffusion (artistic). Derives: Debug, Clone, Copy, PartialEq, Eq.</description>
    </interface>
    <interface>
      <name>apply_dithering</name>
      <kind>function</kind>
      <signature>pub fn apply_dithering(gray: &GrayImage, method: DitheringMethod) -> Result<BinaryImage, DotmaxError></signature>
      <path>src/image/dither.rs</path>
      <description>Unified dithering API. Dispatches to floyd_steinberg(), bayer(), atkinson(), or auto_threshold() based on method. Primary entry point for users. Returns BinaryImage ready for braille mapping.</description>
    </interface>
    <interface>
      <name>floyd_steinberg</name>
      <kind>function</kind>
      <signature>pub fn floyd_steinberg(gray: &GrayImage) -> Result<BinaryImage, DotmaxError></signature>
      <path>src/image/dither.rs</path>
      <description>Floyd-Steinberg error diffusion algorithm. Diffuses quantization error to 4 neighbors with coefficients: 7/16 (right), 3/16 (bottom-left), 5/16 (bottom), 1/16 (bottom-right). Best quality, <15ms target.</description>
    </interface>
    <interface>
      <name>bayer</name>
      <kind>function</kind>
      <signature>pub fn bayer(gray: &GrayImage) -> Result<BinaryImage, DotmaxError></signature>
      <path>src/image/dither.rs</path>
      <description>Bayer ordered dithering with 8×8 matrix. Stateless, parallelizable, fast. Uses standard Bayer pattern (0-63 values, normalized to 0.0-1.0). Good for gradients, <10ms target.</description>
    </interface>
    <interface>
      <name>atkinson</name>
      <kind>function</kind>
      <signature>pub fn atkinson(gray: &GrayImage) -> Result<BinaryImage, DotmaxError></signature>
      <path>src/image/dither.rs</path>
      <description>Atkinson error diffusion algorithm (Apple MacPaint 1984). Diffuses 1/8 error to 6 neighbors, discards 2/8 for softer artistic output. Softer than Floyd-Steinberg, <12ms target.</description>
    </interface>
    <interface>
      <name>BinaryImage (from threshold.rs)</name>
      <kind>struct</kind>
      <signature>pub struct BinaryImage { pub width: u32, pub height: u32, pub pixels: Vec<bool> }</signature>
      <path>src/image/threshold.rs</path>
      <description>Output type for all dithering algorithms. Boolean pixels: true = black (dot on), false = white (dot off). Includes new(), get_pixel(), set_pixel() methods. Optimized for braille mapping in Story 3.5.</description>
    </interface>
    <interface>
      <name>GrayImage (from image crate)</name>
      <kind>type_alias</kind>
      <signature>pub type GrayImage = ImageBuffer<Luma<u8>, Vec<u8>></signature>
      <path>image crate</path>
      <description>Input type for all dithering algorithms. 8-bit grayscale image from image crate. Provided by to_grayscale() function in convert.rs.</description>
    </interface>
    <interface>
      <name>auto_threshold (from threshold.rs)</name>
      <kind>function</kind>
      <signature>pub fn auto_threshold(image: &DynamicImage) -> BinaryImage</signature>
      <path>src/image/threshold.rs</path>
      <description>Fallback for DitheringMethod::None. Combines grayscale conversion + Otsu threshold + binary conversion. Used when user skips dithering step.</description>
    </interface>
  </interfaces>
  <tests>
    <standards>
Following Story 3.3 exceptional testing discipline: >80% line coverage for dither module, unit tests for each algorithm with known patterns, edge case testing (1×1 images, boundaries, uniform images), integration tests for full pipeline (load → resize → grayscale → dither → verify BinaryImage). Use criterion.rs for performance benchmarks (<15ms Floyd-Steinberg, <10ms Bayer, <12ms Atkinson for 160×96 images). Test framework: Rust's built-in test framework with #[cfg(test)] modules. Visual validation via examples/dither_comparison.rs showing all three methods side-by-side. Cross-platform CI testing on Windows, Linux, macOS ensures deterministic output.
    </standards>
    <locations>
      <location>src/image/dither.rs - Unit tests in #[cfg(test)] mod tests block at end of file</location>
      <location>tests/image_loading_tests.rs - Integration tests for full image pipeline</location>
      <location>benches/image_conversion.rs - Performance benchmarks for each dithering algorithm</location>
      <location>examples/dither_comparison.rs - Visual comparison example showing all three methods</location>
    </locations>
    <ideas>
      <test id="AC1" description="Unit test: DitheringMethod enum has all 4 variants (None, FloydSteinberg, Bayer, Atkinson) and derives Debug, Clone, Copy, PartialEq, Eq">Verify enum definition and derives work correctly</test>
      <test id="AC2" description="Unit test Floyd-Steinberg: uniform gray (128) produces dithered pattern, gradient (0-255) shows smooth transition, all-black (0) outputs all false, all-white (255) outputs all true">Test Floyd-Steinberg algorithm correctness with known inputs</test>
      <test id="AC2" description="Unit test Floyd-Steinberg: error diffusion at boundaries (verify errors don't propagate outside image), 1×1 image edge case, 2×2 and 3×3 small images">Test Floyd-Steinberg boundary handling</test>
      <test id="AC3" description="Unit test Bayer: uniform gray (128) shows Bayer pattern, gradient shows ordered pattern, verify Bayer matrix applied correctly (check specific pixels against expected pattern)">Test Bayer algorithm correctness</test>
      <test id="AC3" description="Unit test Bayer: deterministic output (same input → same output), compare Bayer vs Floyd-Steinberg visually (different patterns expected)">Test Bayer properties</test>
      <test id="AC4" description="Unit test Atkinson: uniform gray shows softer pattern than Floyd-Steinberg, gradient shows smooth transition, verify error diffusion to 6 neighbors (1/8 each)">Test Atkinson algorithm correctness</test>
      <test id="AC4" description="Unit test Atkinson: boundary conditions (errors don't propagate outside grid), edge cases (1×1, small images), visual comparison (softer than Floyd-Steinberg)">Test Atkinson boundary handling</test>
      <test id="AC5" description="Integration test: load → resize → grayscale → dither (each method) → verify BinaryImage output, test all three methods produce valid output">Test full pipeline integration</test>
      <test id="AC5" description="Integration test: DitheringMethod::None falls back to auto_threshold, verify all algorithms produce same dimensions as input">Test fallback and dimension preservation</test>
      <test id="AC6" description="Unit test: empty image (0 width or height) returns error, 1×1 image handled gracefully, no .unwrap() or .expect() in production code">Test error handling</test>
      <test id="AC6" description="Integration test: invalid inputs return errors (not panics), cross-platform test (same output on Windows, Linux, macOS)">Test error paths and cross-platform consistency</test>
      <test id="AC8" description="Benchmark: Floyd-Steinberg on 160×96 image (<15ms target), Bayer on 160×96 (<10ms), Atkinson on 160×96 (<12ms)">Validate performance targets with criterion</test>
      <test id="AC8" description="Benchmark: apply_dithering() method selection overhead, larger image (320×192) for scalability testing">Test performance at scale</test>
      <test id="AC9" description="Visual test: examples/dither_comparison.rs loads image, applies all three methods, displays side-by-side with labels and timing">Visual comparison example compiles and runs</test>
    </ideas>
  </tests>
</story-context>
