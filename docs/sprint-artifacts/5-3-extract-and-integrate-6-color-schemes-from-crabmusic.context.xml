<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>5</epicId>
    <storyId>3</storyId>
    <title>Extract and Integrate 6+ Color Schemes from Crabmusic</title>
    <status>drafted</status>
    <generatedAt>2025-11-24</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/5-3-extract-and-integrate-6-color-schemes-from-crabmusic.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer wanting beautiful predefined color palettes</asA>
    <iWant>proven color schemes extracted from crabmusic</iWant>
    <soThat>I can create vibrant graphics without designing colors from scratch</soThat>
    <tasks>
      <task id="1" title="Create Module Structure" ac="9">
        <subtask id="1.1">Create `src/color/schemes.rs` file</subtask>
        <subtask id="1.2">Add `pub mod schemes;` to `src/color/mod.rs`</subtask>
        <subtask id="1.3">Add module-level rustdoc explaining color schemes purpose</subtask>
        <subtask id="1.4">Import `Color` from `crate::color` or `crate::grid` (Story 2.6)</subtask>
      </task>
      <task id="2" title="Implement ColorScheme Struct" ac="1,2">
        <subtask id="2.1">Define `pub struct ColorScheme { name: String, colors: Vec&lt;Color&gt; }`</subtask>
        <subtask id="2.2">Derive `Clone`, `Debug`</subtask>
        <subtask id="2.3">Implement `ColorScheme::new(name, colors)` with validation</subtask>
        <subtask id="2.4">Return error if colors is empty</subtask>
        <subtask id="2.5">Add rustdoc with creation example</subtask>
      </task>
      <task id="3" title="Implement Intensity Sampling" ac="2">
        <subtask id="3.1">Implement `pub fn sample(&amp;self, intensity: f32) -&gt; Color`</subtask>
        <subtask id="3.2">Clamp intensity to 0.0-1.0 range</subtask>
        <subtask id="3.3">Calculate fractional index: `intensity * (colors.len() - 1) as f32`</subtask>
        <subtask id="3.4">Determine lower and upper color indices</subtask>
        <subtask id="3.5">Calculate interpolation factor (fractional part)</subtask>
        <subtask id="3.6">Linear interpolate R, G, B channels separately</subtask>
        <subtask id="3.7">Add rustdoc explaining interpolation behavior</subtask>
      </task>
      <task id="4" title="Implement HSV to RGB Conversion" ac="6">
        <subtask id="4.1">Create internal `fn hsv_to_rgb(h: f32, s: f32, v: f32) -&gt; Color`</subtask>
        <subtask id="4.2">Implement standard HSV→RGB algorithm from crabmusic</subtask>
        <subtask id="4.3">Handle hue wrapping (0-360 degrees)</subtask>
        <subtask id="4.4">Unit test known HSV values</subtask>
      </task>
      <task id="5" title="Extract Rainbow Scheme" ac="3,6">
        <subtask id="5.1">Create `pub fn rainbow() -&gt; ColorScheme`</subtask>
        <subtask id="5.2">Use HSV color space for smooth hue transition (H: 0→300)</subtask>
        <subtask id="5.3">Generate 7+ color stops for gradient</subtask>
        <subtask id="5.4">Add rustdoc describing rainbow appearance</subtask>
        <subtask id="5.5">Unit test: verify red at 0.0, purple at 1.0</subtask>
      </task>
      <task id="6" title="Extract Heat Map Scheme" ac="3">
        <subtask id="6.1">Create `pub fn heat_map() -&gt; ColorScheme`</subtask>
        <subtask id="6.2">Define color stops: Black → Red → Orange → Yellow → White</subtask>
        <subtask id="6.3">Use exact RGB values from crabmusic heat_map_gradient</subtask>
        <subtask id="6.4">Add rustdoc describing heat map appearance</subtask>
        <subtask id="6.5">Unit test: verify black at 0.0, white at 1.0</subtask>
      </task>
      <task id="7" title="Extract Blue-Purple Scheme" ac="3">
        <subtask id="7.1">Create `pub fn blue_purple() -&gt; ColorScheme`</subtask>
        <subtask id="7.2">Define color stops: Blue (0,0,255) → Purple (128,0,127)</subtask>
        <subtask id="7.3">Match crabmusic blue_purple_gradient</subtask>
        <subtask id="7.4">Add rustdoc describing gradient</subtask>
      </task>
      <task id="8" title="Extract Green-Yellow Scheme" ac="3">
        <subtask id="8.1">Create `pub fn green_yellow() -&gt; ColorScheme`</subtask>
        <subtask id="8.2">Define color stops: Green (0,255,0) → Yellow (255,255,0)</subtask>
        <subtask id="8.3">Match crabmusic green_yellow_gradient</subtask>
        <subtask id="8.4">Add rustdoc describing gradient</subtask>
      </task>
      <task id="9" title="Extract Cyan-Magenta Scheme" ac="3">
        <subtask id="9.1">Create `pub fn cyan_magenta() -&gt; ColorScheme`</subtask>
        <subtask id="9.2">Define color stops: Cyan (0,255,255) → Magenta (255,0,255)</subtask>
        <subtask id="9.3">Match crabmusic cyan_magenta_gradient</subtask>
        <subtask id="9.4">Add rustdoc describing gradient</subtask>
      </task>
      <task id="10" title="Implement Grayscale Scheme" ac="3">
        <subtask id="10.1">Create `pub fn grayscale() -&gt; ColorScheme`</subtask>
        <subtask id="10.2">Define color stops: Black (0,0,0) → White (255,255,255)</subtask>
        <subtask id="10.3">Add rustdoc describing gradient</subtask>
        <subtask id="10.4">Unit test: verify black at 0.0, gray at 0.5, white at 1.0</subtask>
      </task>
      <task id="11" title="Implement Monochrome Scheme" ac="5">
        <subtask id="11.1">Create `pub fn monochrome() -&gt; ColorScheme`</subtask>
        <subtask id="11.2">Return scheme with single white color</subtask>
        <subtask id="11.3">Sample always returns white regardless of intensity</subtask>
        <subtask id="11.4">Add rustdoc explaining use case</subtask>
      </task>
      <task id="12" title="Implement Scheme Discovery" ac="4">
        <subtask id="12.1">Create `pub fn list_schemes() -&gt; Vec&lt;String&gt;`</subtask>
        <subtask id="12.2">Return all scheme names in consistent order</subtask>
        <subtask id="12.3">Create `pub fn get_scheme(name: &amp;str) -&gt; Option&lt;ColorScheme&gt;`</subtask>
        <subtask id="12.4">Implement case-insensitive name matching</subtask>
        <subtask id="12.5">Add rustdoc with discovery example</subtask>
      </task>
      <task id="13" title="Write Comprehensive Unit Tests" ac="7">
        <subtask id="13.1">Create test module in `src/color/schemes.rs`</subtask>
        <subtask id="13.2">Test `ColorScheme::new()` with valid and empty colors</subtask>
        <subtask id="13.3">Test `sample()` boundary conditions (0.0, 0.5, 1.0)</subtask>
        <subtask id="13.4">Test `sample()` with out-of-range values (clamping)</subtask>
        <subtask id="13.5">Test each predefined scheme returns expected colors</subtask>
        <subtask id="13.6">Test `list_schemes()` returns all 7 schemes</subtask>
        <subtask id="13.7">Test `get_scheme()` with valid and invalid names</subtask>
        <subtask id="13.8">Test case-insensitive matching</subtask>
        <subtask id="13.9">Run tests: `cargo test color::schemes`</subtask>
      </task>
      <task id="14" title="Create Visual Example" ac="8">
        <subtask id="14.1">Create `examples/color_schemes.rs`</subtask>
        <subtask id="14.2">Create BrailleGrid for gradient display</subtask>
        <subtask id="14.3">For each scheme: render horizontal gradient bar</subtask>
        <subtask id="14.4">Apply colors using Story 5.2 conversion functions</subtask>
        <subtask id="14.5">Output to terminal with color escape codes</subtask>
        <subtask id="14.6">Add example description to `examples/README.md`</subtask>
        <subtask id="14.7">Run example: `cargo run --example color_schemes`</subtask>
      </task>
      <task id="15" title="Benchmark and Performance Validation" ac="2">
        <subtask id="15.1">Add `ColorScheme::sample()` benchmark to `benches/color_rendering.rs`</subtask>
        <subtask id="15.2">Target: &lt;100ns per sample call</subtask>
        <subtask id="15.3">Run benchmarks: `cargo bench`</subtask>
        <subtask id="15.4">Optimize if needed (pre-compute color array?)</subtask>
      </task>
      <task id="16" title="Integration and Exports" ac="9">
        <subtask id="16.1">Update `src/color/mod.rs` to re-export `ColorScheme`, `list_schemes`, `get_scheme`</subtask>
        <subtask id="16.2">Update `src/lib.rs` to re-export color scheme types</subtask>
        <subtask id="16.3">Run full test suite: `cargo test`</subtask>
        <subtask id="16.4">Run clippy: `cargo clippy -- -D warnings`</subtask>
        <subtask id="16.5">Run rustfmt: `cargo fmt`</subtask>
        <subtask id="16.6">Generate docs: `cargo doc --open`</subtask>
        <subtask id="16.7">Verify zero rustdoc warnings</subtask>
        <subtask id="16.8">Update CHANGELOG.md with Story 5.3 completion</subtask>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <ac id="1" title="ColorScheme Struct Implemented">
      <criterion>`ColorScheme` struct in `src/color/schemes.rs` with: name: String, colors: Vec&lt;Color&gt;</criterion>
      <criterion>Implements `Clone` and `Debug`</criterion>
      <criterion>Constructor: `ColorScheme::new(name: impl Into&lt;String&gt;, colors: Vec&lt;Color&gt;) -&gt; Self`</criterion>
      <criterion>Returns `EmptyColorScheme` error if colors vec is empty</criterion>
    </ac>
    <ac id="2" title="Intensity Sampling Function">
      <criterion>`ColorScheme::sample(&amp;self, intensity: f32) -&gt; Color` method</criterion>
      <criterion>Maps intensity (0.0-1.0) to interpolated color</criterion>
      <criterion>Linear RGB interpolation between color stops</criterion>
      <criterion>Boundary behavior: intensity=0.0 returns colors[0], intensity=1.0 returns colors[last], intensity=0.5 returns midpoint</criterion>
      <criterion>Benchmark shows &lt;100ns per sample (criterion.rs test)</criterion>
    </ac>
    <ac id="3" title="Six Predefined Schemes Extracted from Crabmusic">
      <criterion>ColorScheme::rainbow() - Red → Orange → Yellow → Green → Blue → Purple</criterion>
      <criterion>ColorScheme::heat_map() - Black → Red → Orange → Yellow → White</criterion>
      <criterion>ColorScheme::blue_purple() - Blue → Purple gradient</criterion>
      <criterion>ColorScheme::green_yellow() - Green → Yellow gradient</criterion>
      <criterion>ColorScheme::cyan_magenta() - Cyan → Magenta gradient</criterion>
      <criterion>ColorScheme::grayscale() - Black → Gray → White</criterion>
      <criterion>Each scheme produces visually identical output to crabmusic</criterion>
    </ac>
    <ac id="4" title="Scheme Discovery API">
      <criterion>`pub fn list_schemes() -&gt; Vec&lt;String&gt;` returns all scheme names</criterion>
      <criterion>`pub fn get_scheme(name: &amp;str) -&gt; Option&lt;ColorScheme&gt;` retrieves by name</criterion>
      <criterion>Case-insensitive name matching</criterion>
    </ac>
    <ac id="5" title="Monochrome Scheme Handling">
      <criterion>`ColorScheme::monochrome()` returns scheme that maps all intensities to white</criterion>
      <criterion>Allows unified API even when colors not needed</criterion>
      <criterion>Unit tests verify monochrome behavior</criterion>
    </ac>
    <ac id="6" title="HSV to RGB Conversion Helper">
      <criterion>Internal `hsv_to_rgb(h: f32, s: f32, v: f32) -&gt; Color` function</criterion>
      <criterion>Used by rainbow scheme for smooth hue transitions</criterion>
      <criterion>H: 0-360 degrees, S: 0-1, V: 0-1</criterion>
      <criterion>Unit tests verify HSV conversion accuracy</criterion>
    </ac>
    <ac id="7" title="Comprehensive Unit Tests">
      <criterion>Test each predefined scheme produces expected colors</criterion>
      <criterion>Test boundary conditions (intensity 0.0, 0.5, 1.0)</criterion>
      <criterion>Test invalid intensity clamping (&lt; 0.0 → 0.0, &gt; 1.0 → 1.0)</criterion>
      <criterion>Test scheme discovery (list_schemes, get_scheme)</criterion>
      <criterion>Test custom scheme creation</criterion>
      <criterion>Achieve &gt;80% code coverage for schemes module</criterion>
    </ac>
    <ac id="8" title="Visual Example">
      <criterion>Create `examples/color_schemes.rs`</criterion>
      <criterion>Displays all 6+ schemes as horizontal gradients</criterion>
      <criterion>Uses braille grid with colored output</criterion>
      <criterion>Renders correctly in true color terminal</criterion>
    </ac>
    <ac id="9" title="Production-Quality Documentation">
      <criterion>Rustdoc on all public types and functions with examples</criterion>
      <criterion>Document each scheme's visual appearance</criterion>
      <criterion>Document intensity interpolation behavior</criterion>
      <criterion>Zero rustdoc warnings</criterion>
    </ac>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/architecture.md" relevance="high">Core architecture document with ADR patterns and module structure</doc>
      <doc path="docs/sprint-artifacts/tech-spec-epic-5.md" relevance="critical">Epic 5 tech spec - detailed implementation guidance for color stories</doc>
      <doc path="docs/sprint-artifacts/5-2-implement-rgb-to-ansi-color-conversion.md" relevance="high">Story 5.2 (prerequisite) - defines Color types and convert module</doc>
    </docs>
    <code>
      <file path="src/color/mod.rs" relevance="critical">
        <purpose>Color module root - add `pub mod schemes;` here</purpose>
        <exports>rgb_to_ansi16, rgb_to_ansi256, rgb_to_terminal_color, escape functions</exports>
        <pattern>Re-export commonly used functions at module level</pattern>
      </file>
      <file path="src/color/convert.rs" relevance="high">
        <purpose>RGB→ANSI conversion functions - pattern to follow</purpose>
        <pattern>Inline const functions, comprehensive rustdoc, unit tests in same file</pattern>
        <imports>use crate::utils::terminal_caps::ColorCapability;</imports>
      </file>
      <file path="src/grid.rs" relevance="critical">
        <purpose>Color struct definition (lines 28-62)</purpose>
        <struct>
          pub struct Color { pub r: u8, pub g: u8, pub b: u8 }
          Color::rgb(r, g, b) - constructor
          Color::black() - (0,0,0)
          Color::white() - (255,255,255)
        </struct>
        <derives>Debug, Clone, Copy, PartialEq, Eq, Hash</derives>
      </file>
      <file path="src/lib.rs" relevance="medium">
        <purpose>Crate root - update public exports for ColorScheme types</purpose>
      </file>
      <file path="../crabmusic/src/visualization/color_schemes.rs" relevance="critical">
        <purpose>SOURCE CODE - Extract color schemes from here</purpose>
        <schemes>
          <scheme name="rainbow">HSV-based, hue 0→300 degrees, rainbow_gradient()</scheme>
          <scheme name="heat_map">Black→Red→Orange→Yellow→White, 4 segments at 0.25 intervals</scheme>
          <scheme name="blue_purple">Blue(0,0,255)→Purple(128,0,127), linear interpolation</scheme>
          <scheme name="green_yellow">Green(0,255,0)→Yellow(255,255,0), R channel ramps</scheme>
          <scheme name="cyan_magenta">Cyan(0,255,255)→Magenta(255,0,255), R up, G down</scheme>
          <scheme name="monochrome">Returns None (no color)</scheme>
        </schemes>
        <hsv_function>hsv_to_rgb(h, s, v) at lines 135-159 - standard algorithm</hsv_function>
      </file>
    </code>
    <dependencies>
      <crate name="ratatui" version="0.29" usage="Terminal UI framework (not directly used in schemes)"/>
      <crate name="crossterm" version="0.29" usage="Terminal I/O (color output in examples)"/>
      <crate name="thiserror" version="2.0" usage="Error handling - define EmptyColorScheme error"/>
      <crate name="tracing" version="0.1" usage="Structured logging (use sparingly in hot paths)"/>
      <crate name="criterion" version="0.7" usage="Benchmarking ColorScheme::sample() performance"/>
      <devCrate name="tracing-subscriber" version="0.3" usage="Test logging"/>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="performance" target="ColorScheme::sample()">Must complete in &lt;100ns per call - avoid allocations in hot path</constraint>
    <constraint type="memory">ColorScheme should be Clone + lightweight; consider pre-computing colors in constructor</constraint>
    <constraint type="compatibility">Must use existing Color struct from src/grid.rs (DO NOT create new Color type)</constraint>
    <constraint type="api">Function signatures must match crabmusic where applicable for visual parity</constraint>
    <constraint type="error">Use thiserror for EmptyColorScheme error, integrate with DotmaxError enum</constraint>
    <constraint type="clippy">Must pass `cargo clippy -- -D warnings` with pedantic and nursery lints</constraint>
    <constraint type="msrv">Minimum Rust 1.70 - avoid unstable features</constraint>
    <constraint type="zero-panics">Never panic - return Result for fallible operations</constraint>
  </constraints>

  <interfaces>
    <interface name="ColorScheme">
      <signature>pub struct ColorScheme { name: String, colors: Vec&lt;Color&gt; }</signature>
      <methods>
        <method>pub fn new(name: impl Into&lt;String&gt;, colors: Vec&lt;Color&gt;) -> Result&lt;Self, DotmaxError&gt;</method>
        <method>pub fn sample(&amp;self, intensity: f32) -> Color</method>
        <method>pub fn name(&amp;self) -> &amp;str</method>
        <method>pub fn colors(&amp;self) -> &amp;[Color]</method>
      </methods>
    </interface>
    <interface name="Predefined Schemes">
      <function>pub fn rainbow() -> ColorScheme</function>
      <function>pub fn heat_map() -> ColorScheme</function>
      <function>pub fn blue_purple() -> ColorScheme</function>
      <function>pub fn green_yellow() -> ColorScheme</function>
      <function>pub fn cyan_magenta() -> ColorScheme</function>
      <function>pub fn grayscale() -> ColorScheme</function>
      <function>pub fn monochrome() -> ColorScheme</function>
    </interface>
    <interface name="Discovery API">
      <function>pub fn list_schemes() -> Vec&lt;String&gt;</function>
      <function>pub fn get_scheme(name: &amp;str) -> Option&lt;ColorScheme&gt;</function>
    </interface>
    <integration>
      <use_with>Story 5.2 rgb_to_terminal_color() for outputting sampled colors</use_with>
      <use_with>BrailleGrid::set_cell_color() for applying scheme colors to grid cells</use_with>
    </integration>
  </interfaces>

  <tests>
    <standards>
      <standard>Tests in #[cfg(test)] mod at end of src/color/schemes.rs</standard>
      <standard>Follow existing pattern in src/color/convert.rs (AC-labeled test sections)</standard>
      <standard>Use assert_eq! for exact value checks, assert! for range checks</standard>
      <standard>Each AC gets its own test section with clear comments</standard>
      <standard>Target &gt;80% code coverage for new module</standard>
    </standards>
    <locations>
      <location>src/color/schemes.rs - Unit tests (#[cfg(test)])</location>
      <location>benches/color_rendering.rs - Benchmark ColorScheme::sample()</location>
      <location>examples/color_schemes.rs - Visual integration test</location>
    </locations>
    <ideas>
      <test_idea ac="1">test_colorscheme_new_valid - create scheme with 3 colors</test_idea>
      <test_idea ac="1">test_colorscheme_new_empty_returns_error - empty Vec should error</test_idea>
      <test_idea ac="2">test_sample_boundary_0 - intensity 0.0 returns first color</test_idea>
      <test_idea ac="2">test_sample_boundary_1 - intensity 1.0 returns last color</test_idea>
      <test_idea ac="2">test_sample_midpoint - intensity 0.5 returns interpolated middle</test_idea>
      <test_idea ac="2">test_sample_clamps_negative - intensity -0.5 → 0.0</test_idea>
      <test_idea ac="2">test_sample_clamps_above_one - intensity 1.5 → 1.0</test_idea>
      <test_idea ac="3">test_rainbow_red_at_0 - rainbow().sample(0.0) ≈ red</test_idea>
      <test_idea ac="3">test_rainbow_purple_at_1 - rainbow().sample(1.0) ≈ purple</test_idea>
      <test_idea ac="3">test_heat_map_black_at_0 - heat_map().sample(0.0) == black</test_idea>
      <test_idea ac="3">test_heat_map_white_at_1 - heat_map().sample(1.0) == white</test_idea>
      <test_idea ac="4">test_list_schemes_returns_7 - list_schemes().len() == 7</test_idea>
      <test_idea ac="4">test_get_scheme_case_insensitive - get_scheme("RAINBOW") == get_scheme("rainbow")</test_idea>
      <test_idea ac="4">test_get_scheme_invalid_returns_none - get_scheme("nonexistent") == None</test_idea>
      <test_idea ac="5">test_monochrome_always_white - all intensities return white</test_idea>
      <test_idea ac="6">test_hsv_to_rgb_red - hsv(0, 1, 1) == (255, 0, 0)</test_idea>
      <test_idea ac="6">test_hsv_to_rgb_green - hsv(120, 1, 1) == (0, 255, 0)</test_idea>
      <test_idea ac="6">test_hsv_to_rgb_blue - hsv(240, 1, 1) == (0, 0, 255)</test_idea>
      <test_idea ac="7">test_all_schemes_boundary_coverage - loop all schemes, test 0.0/0.5/1.0</test_idea>
      <benchmark>criterion benchmark: ColorScheme::sample() must be &lt;100ns</benchmark>
    </ideas>
  </tests>
</story-context>
