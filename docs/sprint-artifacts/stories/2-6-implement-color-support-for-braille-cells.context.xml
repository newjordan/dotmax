<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>6</storyId>
    <title>Implement Color Support for Braille Cells</title>
    <status>drafted</status>
    <generatedAt>2025-11-18</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/2-6-implement-color-support-for-braille-cells.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer creating colored terminal graphics</asA>
    <iWant>per-cell RGB color assignment with terminal color conversion</iWant>
    <soThat>braille output can be vibrant and visually rich</soThat>
    <tasks>
- Task 1: Implement Color struct in src/grid.rs (AC: #1, #2)
- Task 2: Extend BrailleGrid with color support (AC: #3, #4, #5)
- Task 3: Implement color rendering in TerminalRenderer (AC: #6)
- Task 4: Write comprehensive color tests (AC: #7)
- Task 5: Add integration test for colored rendering (AC: #6)
- Task 6: Add example demonstrating color usage (AC: #6)
- Task 7: Run quality checks and verify implementation (AC: all)
    </tasks>
  </story>

  <acceptanceCriteria>
1. `src/grid.rs` contains `Color` struct with fields: `r: u8`, `g: u8`, `b: u8`
2. `Color::rgb(r, g, b)`, `Color::black()`, `Color::white()` constructors provided
3. `BrailleGrid::enable_color_support()` allocates color buffer (`Option<Vec<Vec<Color>>>` → `Some`)
4. `BrailleGrid::set_cell_color(x, y, color) -> Result<(), DotmaxError>` assigns RGB to cell (validates bounds)
5. `BrailleGrid::get_cell_color(x, y) -> Option<Color>` reads cell color (returns None if no color set or color support disabled)
6. `TerminalRenderer::render()` applies ANSI color codes when rendering colored cells
7. Unit tests verify: color assignment, retrieval, rendering with colors, monochrome fallback
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-2.md</path>
        <title>Technical Specification - Epic 2: Core Braille Rendering Engine</title>
        <section>Story 2.6: Implement Color Support for Braille Cells</section>
        <snippet>AC 2.6.1-2.6.7 define Color struct with r,g,b fields, constructors (rgb, black, white), BrailleGrid color methods (enable_color_support, set_cell_color, get_cell_color), and TerminalRenderer color application via ANSI codes</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document - dotmax</title>
        <section>FR8: Grid Color Support</section>
        <snippet>Users can create grids with per-cell color support for vibrant terminal graphics</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document - dotmax</title>
        <section>FR32: RGB Color Assignment</section>
        <snippet>Assign RGB colors to individual braille cells for colorful output</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture - dotmax</title>
        <section>Color Support Data Model</section>
        <snippet>Colors stored as Option&lt;Vec&lt;Option&lt;Color&gt;&gt;&gt; in BrailleGrid. Lazy allocation pattern - only allocate when needed. Ratatui Style::fg() used for rendering, not manual ANSI codes</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/2-6-implement-color-support-for-braille-cells.md</path>
        <title>Story 2.6 - Dev Notes</title>
        <section>Learnings from Story 2.5</section>
        <snippet>Color buffer already exists as `colors: Vec&lt;Option&lt;Color&gt;&gt;` (flat array). Cell index: y * width + x. Story 2.5 implemented resize synchronization for color buffer</snippet>
      </doc>
      <doc>
        <path>docs/adr</path>
        <title>Architecture Decision Records</title>
        <section>ADR 0002: Error Handling with thiserror</section>
        <snippet>Use thiserror for structured error handling. All public methods return Result&lt;T, DotmaxError&gt;</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/grid.rs</path>
        <kind>module</kind>
        <symbol>Color</symbol>
        <lines>22-59</lines>
        <reason>Color struct already defined with rgb(), black(), white() constructors. AC #1 and #2 already implemented - verify and add rustdoc if needed</reason>
      </artifact>
      <artifact>
        <path>src/grid.rs</path>
        <kind>struct</kind>
        <symbol>BrailleGrid</symbol>
        <lines>158-173</lines>
        <reason>Grid structure with colors field (Vec&lt;Option&lt;Color&gt;&gt;). Need to add: enable_color_support(), set_cell_color(), get_cell_color(), clear_colors() methods</reason>
      </artifact>
      <artifact>
        <path>src/render.rs</path>
        <kind>module</kind>
        <symbol>TerminalRenderer::render</symbol>
        <lines>226-252</lines>
        <reason>Render method currently creates monochrome Span::raw(text). Need to check grid.get_cell_color() and apply ratatui Style::fg() when color present</reason>
      </artifact>
      <artifact>
        <path>src/error.rs</path>
        <kind>module</kind>
        <symbol>DotmaxError</symbol>
        <lines>1-100</lines>
        <reason>Error types for bounds validation. OutOfBounds variant should exist from Story 2.4</reason>
      </artifact>
      <artifact>
        <path>tests/integration_tests.rs</path>
        <kind>test file</kind>
        <symbol>integration tests</symbol>
        <lines>1-50</lines>
        <reason>Add integration test for colored rendering workflow (Task 5)</reason>
      </artifact>
      <artifact>
        <path>examples/hello_braille.rs</path>
        <kind>example</kind>
        <symbol>example pattern</symbol>
        <lines>1-50</lines>
        <reason>Reference for creating color_demo.rs example (Task 6)</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <crate name="ratatui" version="0.29" feature="default">Terminal UI framework - provides Style::fg() for color rendering</crate>
        <crate name="crossterm" version="0.29" feature="default">Cross-platform terminal I/O - used by TerminalRenderer</crate>
        <crate name="thiserror" version="2.0" feature="default">Error handling derive macros - DotmaxError uses #[error] and #[from]</crate>
        <crate name="tracing" version="0.1" feature="default">Structured logging - #[instrument] attribute for methods</crate>
      </rust>
      <dev-dependencies>
        <crate name="criterion" version="0.7" features="html_reports">Benchmarking (not needed for Story 2.6)</crate>
        <crate name="tracing-subscriber" version="0.3">Test logging (optional for debugging test failures)</crate>
      </dev-dependencies>
    </dependencies>
  </artifacts>

  <constraints>
- Zero Panics Policy: All public methods return Result&lt;T, DotmaxError&gt; or safe primitives (ADR 0002)
- Bounds validation required: set_cell_color() must validate x,y coordinates and return Err(OutOfBounds) for invalid input
- get_cell_color() returns Option&lt;Color&gt; (not Result) - out of bounds returns None, not error
- Color buffer uses lazy allocation pattern - only allocate when enable_color_support() called
- Colors stored as flat Vec&lt;Option&lt;Color&gt;&gt; using index = y * width + x (Story 2.5 pattern)
- Use ratatui Style::fg() for color rendering, NOT manual ANSI codes
- Tracing instrumentation: Use #[instrument(skip(self))] for methods with &amp;mut self
- Hot paths: get_cell_color(), set_cell_color() are O(1) direct array access - no performance optimization needed
- Testing: Minimum 80% code coverage for color methods, all error paths tested
- All public methods require rustdoc with examples
  </constraints>
  <interfaces>
    <interface>
      <name>Color::rgb</name>
      <kind>constructor</kind>
      <signature>pub const fn rgb(r: u8, g: u8, b: u8) -> Self</signature>
      <path>src/grid.rs:40</path>
    </interface>
    <interface>
      <name>Color::black</name>
      <kind>constructor</kind>
      <signature>pub const fn black() -> Self</signature>
      <path>src/grid.rs:46</path>
    </interface>
    <interface>
      <name>Color::white</name>
      <kind>constructor</kind>
      <signature>pub const fn white() -> Self</signature>
      <path>src/grid.rs:51</path>
    </interface>
    <interface>
      <name>BrailleGrid::enable_color_support</name>
      <kind>method</kind>
      <signature>pub fn enable_color_support(&amp;mut self)</signature>
      <path>src/grid.rs - TO IMPLEMENT</path>
    </interface>
    <interface>
      <name>BrailleGrid::set_cell_color</name>
      <kind>method</kind>
      <signature>pub fn set_cell_color(&amp;mut self, x: usize, y: usize, color: Color) -> Result&lt;(), DotmaxError&gt;</signature>
      <path>src/grid.rs - TO IMPLEMENT</path>
    </interface>
    <interface>
      <name>BrailleGrid::get_cell_color</name>
      <kind>method</kind>
      <signature>pub fn get_cell_color(&amp;self, x: usize, y: usize) -> Option&lt;Color&gt;</signature>
      <path>src/grid.rs - TO IMPLEMENT</path>
    </interface>
    <interface>
      <name>BrailleGrid::clear_colors</name>
      <kind>method</kind>
      <signature>pub fn clear_colors(&amp;mut self)</signature>
      <path>src/grid.rs - TO IMPLEMENT</path>
    </interface>
    <interface>
      <name>TerminalRenderer::render</name>
      <kind>method</kind>
      <signature>pub fn render(&amp;mut self, grid: &amp;BrailleGrid) -> Result&lt;(), DotmaxError&gt;</signature>
      <path>src/render.rs:226 - TO MODIFY for color support</path>
    </interface>
    <interface>
      <name>DotmaxError::OutOfBounds</name>
      <kind>error variant</kind>
      <signature>OutOfBounds { x: usize, y: usize, width: usize, height: usize }</signature>
      <path>src/error.rs - already exists from Story 2.4</path>
    </interface>
  </interfaces>
  <tests>
    <standards>
Unit tests use #[cfg(test)] module in source files (src/grid.rs, src/render.rs). Integration tests in tests/ directory. Story 2.5 established patterns: bounds validation tests, edge case tests, invariant checks. All error paths must be tested. Use assert!, assert_eq!, assert!(matches!(result, Err(DotmaxError::OutOfBounds { .. }))). Minimum 80% code coverage for new methods.
    </standards>
    <locations>
- Unit tests: src/grid.rs #[cfg(test)] mod tests
- Integration tests: tests/integration_tests.rs
- Examples: examples/color_demo.rs (new)
- Benchmarks: benches/rendering.rs (no changes needed for Story 2.6)
    </locations>
    <ideas>
      <idea ac="1,2">
        - Test Color::rgb() constructor creates correct r,g,b values
        - Test Color::black() returns (0,0,0)
        - Test Color::white() returns (255,255,255)
        - Test Color implements PartialEq (color1 == color2)
      </idea>
      <idea ac="3">
        - Test enable_color_support() allocates buffer matching grid dimensions (width × height)
        - Test enable_color_support() is idempotent (calling twice doesn't break anything)
        - Test colors initially None after allocation
      </idea>
      <idea ac="4,5">
        - Test set_cell_color() with valid coords, verify via get_cell_color()
        - Test set_cell_color() out of bounds returns Err(OutOfBounds)
        - Test get_cell_color() returns None when colors disabled
        - Test get_cell_color() returns None for cells with no color set
        - Test get_cell_color() out of bounds returns None (not error)
      </idea>
      <idea ac="6">
        - Integration test: Create grid, enable colors, set dots and colors, render to terminal
        - Test monochrome fallback when colors not enabled
        - Test mixed colored/non-colored cells render correctly
      </idea>
      <idea ac="7">
        - Test clear_colors() resets all colors to None
        - Test color buffer resizes with grid (Story 2.5 already handles, verify still works)
      </idea>
    </ideas>
  </tests>
</story-context>
